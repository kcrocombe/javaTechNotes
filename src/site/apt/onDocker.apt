Notes on Docker

*Introduction

  Docker is an open platform for developing, shipping, and running applications as Containers. A container is a packaged, self-contained, runnable instance of an image that is largely isolated from other other such containers that might be running on that same host. In general, they just use the kernel of the host machine - everything else is within the container.  Because they are packaged and self-contained, they can be lifted and dropped into another environment as a single unit: and they can be guaranteed to run exactly as they did in the original environment.

  The isolation, and the security that that brings, allows many containers to be run simultaneously on a given host.

  This isolation means that, from the perspective of the application running in the container, it appears to have the machine entirely to itself: it has its own operating system, libraries, script, jars, ports etc, process space, network i/f. The contents of the container can vary from the extremely simple (just a single statically linked executable), to very complex (a full operating system, hosting application server, database server (ie a full virtual machine)).

  This has many similarities to that of a Virtual Machine, however it is much more lightweight: there is none of the extra load that running an operating system on a hypervisor imposes. Instead, they run directly on the <<hosts machine kernel>> as a single process, and also can run with the native speed of the underlying host. This also means that they be started and shutdown extremely quickly (in contrast to a virtual machine).

  For example, a newly created container built from an existing image may only take an additional 12 kilobytes of disk space. On the other hand, a new virtual machine created from a golden image might require hundreds or thousands of megabytes.

  Containers will run on any x64 Linux Kernel that supports:

    * Namespaces;

    * Control groups;

    * overlaying filesystems (such as AUFS - Another Union File System).

    []

  (There are also workarounds that will allow Docker to run on Windows, Mac etc.)

  It is NOT:

    * a virtual platform;

    * a workload management tool;

    * a deployment framework.

    []


  Containers are best used for applications that are stateless, or where the state has been externalised to a database, or other datastore, web front ends, back-end apis, short running tasks like maintenance scripts.

  And whilst it is harder to deploy things such as database server, it is still possible.

====

*Docker and Dev Ops

  By using an image repository as the hand-off point, Docker allows the responsibility of building the application image to be separated from the deployment and operation of the container. What this means in practice is that development teams can build their application with all of its dependencies, run it in development and test environments, and then just ship the exact same bundle of application and dependencies to production.

  Because those bundles all look the same from the outside, operations engineers can then build or install standard tooling to deploy and run the applications. The cycle pictured in the figure below then looks somewhat like this:

[./images/dockerWorkflow1.png] Docker Workflow

    [[1]] Developers build the Docker image and ship it to the registry.

    [[1]] Operations engineers provide configuration details to the container and provision resources.

    [[1]] Developers trigger deployment.

  This is possible because Docker allows all of the dependency issues to be discovered during the development and test cycles. By the time the application is ready for first deployment, that work is done.

====

*Basic Architecture

  Docker is a highly service-based architecture. A central concept is that the images and the constituent image layers that make them up are shareable. As a consequence, shared repositories and registries, and mechanics to fetch and store existing/new image combinations to those registries/repositories figure largely.

  The simple architecture is indicated below.

[./images/basicDockerArchitecure.png]

**The Docker daemon

  The Docker daemon (<<<dockerd>>>) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.

**The Docker client

  The Docker client (<<<docker>>>) is the primary way that many Docker users interact with Docker. When you use commands such as docker run, the client sends these commands to <<<dockerd>>>, which carries them out. The docker command uses the Docker API. The Docker client can communicate with more than one daemon.

**Docker registries

  A Docker registry stores Docker images and makes them available over a network. Docker Hub is a public registry available on the internet that anyone can use. Docker is configured to look for images on Docker Hub by default. There are several other public registries that can be used in its stead ( e.g. quay.io (redhat) and glr.io (Google)). If necessary, you can even run your own private registry. If you use Docker Datacenter (DDC), it includes Docker Trusted Registry (DTR).

  Docker retains images that are currently in use, or that have been locally built, in a local registry. This will simply be disk space that is managed be the Docker Daemon. All executing containers will be running images loaded from within this local registry.

  When you use the <<<docker pull>>> or <<<docker run>>> commands, the required images are pulled from the configured remote registry into the local registry.

  When you use the docker push command, your image is pushed from your local registry to your configured remote registry.

  Note: 'local' in this context means a disk area managed by the Docker server. It is perfectly possible for a remote registry to be a served by a Registry Server which is located on the same machine as the docker server.

====

*The underlying technology

  Docker is written in the Go language and takes advantage of particular features of the Linux kernel to deliver its functionality:

    * Namespaces;

    * Control Groups;

    * Union File Systems;

    * Container Formats.

    []

  These are described below.


**Namespaces

  Docker uses a technology called <<<namespaces>>> to provide the isolated workspace called the container. When you run a container, Docker creates a set of namespaces for that container.

  These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.

  Docker Engine uses namespaces such as the following on Linux:

    * The pid namespace: Process isolation (PID: Process ID).

    * The net namespace: Managing network interfaces (NET: Networking).

    * The ipc namespace: Managing access to IPC resources (IPC: InterProcess Communication).

    * The mnt namespace: Managing filesystem mount points (MNT: Mount).

    * The uts namespace: Isolating kernel and version identifiers. (UTS: Unix Timesharing System).


**Control groups

  Docker Engine on Linux also relies on another technology called control groups (cgroups). A cgroup limits an application to a specific set of resources. Control groups allow Docker Engine to share available hardware resources to containers and optionally enforce limits and constraints. For example, you can limit the memory available to a specific container.

  Control Groups, or cgroups for short, allow you to set limits on resources for processes and their children. This is the mechanism that Docker uses to control limits on memory, swap, and CPU resources

**Union file systems

  Union file systems, or UnionFS, are file systems that operate by creating layers, making them very lightweight and fast. Docker Engine uses UnionFS to provide the building blocks for containers. Docker Engine can use multiple UnionFS variants, including AUFS, btrfs, vfs, and DeviceMapper.

**Container format

  Docker Engine combines the namespaces, control groups, and UnionFS into a wrapper called <<a container format>>. The default container format is libcontainer. In the future, Docker may support other container formats by integrating with technologies such as BSD Jails or Solaris Zones.

====

*The Building Blocks of Docker

**Images

  An image is a read-only <<template>> with <<instructions>> for creating a Docker container.

  Every Docker Container will be based on an <<image>>.

  Every Docker image consists of one or more filesystem layers that generally have a direct one-to-one mapping to each individual build step used to create that image.

  In general, they will be composite objects: often, an image is based on another image, with some additional customisation. For example, you may build an image which is based on the ubuntu image, but then installs the Apache web server and then your application, and the configuration details needed to make your application run.

  You might create your own images or you might only use those created by others and published in a registry.

  To build your own image, you create a <<Dockerfile>> with a simple syntax for defining the steps needed to create the image and then run it. Each instruction in a Dockerfile creates a filesystem layer in the image.

  When you change the Dockerfile and rebuild the image, only those layers which have changed need to rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualisation technologies.

  Images ultimately are actual files. Consider the following:

---
    docker images --no-trunc

    REPOSITORY                 TAG                 IMAGE ID                                                                  CREATED             SIZE
  ubuntu                     latest              sha256:ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0   2 days ago          64.2MB
  registry                   2                   sha256:f32a97de94e13d29835a19851acd6cbc7979d1d50f703725541e44bb89a1ce91   10 months ago       25.8MB
---

  This shows the two images currently available on the local machine:

    * ubuntu:latest

    * registry:2

    []

  Ultimately these labels are just a convenience notation for the actual image file, which are:

---
    sha256:ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0

    sha256:f32a97de94e13d29835a19851acd6cbc7979d1d50f703725541e44bb89a1ce91
---

  respectively. Note that these are ACTUAL filenames. The files themselves can be viewed on the machine to which they have been downloaded.

---
    /var/lib/docker/image/overlay2/imagedb/content/sha256/ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0

    /var/lib/docker/image/overlay2/imagedb/content/sha256/f32a97de94e13d29835a19851acd6cbc7979d1d50f703725541e44bb89a1ce91
---

  When they are viewed, they are just simple json formatted text files.

  The files are named according to the SHA-256 hash of their actual contents. This can be easily demonstrated using the sha256sum utility:

---
  sha256sum /var/lib/docker/image/overlay2/imagedb/content/sha256/ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0
  ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0  ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0
---

  These files are known as manifests, and contain all the metadata necessary for the container to construct and run. Because the image filename is based on a hash of its content, 2 files bearing the same name can be guaranteed to hold the same content. To all intents and purposes, image Ids are globally unique.

  The contents of the manifest is essentially

    * some metadata describing how the image is to be used: its environment, working directory, any volumes that will be mounted to it, its entry point, the steps involved in itc creation, etc

    * an ordered list of image layers from which this image is built.

    []

  This list of layers is also specified in terms of a set of files names after the sha256 hash of their contents, e.g.:

---
  "sha256:96eda0f553ba9988a216cea7cf016d18d5f036677d411883b642c4c8c70e301b",
  "sha256:bd95983a8d99e89ec7c7558839a72a79e92ce8c5a6697ad704e341d0d3c43cd5",
  "sha256:293b479c17a5448de0814a3c614ac15a0d192a7c2c56f53478f6e3d5cc5cb345",
  "sha256:fa1693d66d0b743e6ef621392026f411dad99750ec16926ffd78104a82a123e7"
---

  These files are also digests, and may reference further images. Eventually however they will resolve to the sha256 hash of a gzipped tar file that constitute the actual layer.

  Every image id is globally unique.

  An image ID that includes the digest component is called a content addressable image identifier (CAIID). This refers to a specific layer containing specific content, instead of simply referring to a particular and potentially changing layer

**Repository

  This is perhaps not what you would intuitively think. It is <<NOT>> e.g. dockerHub or Quay.io where collections of reusable images are stored (these are <<registries>>). It is more that the reusable images <<ARE>> the repositories.

  A repository is roughly defined as a named bucket of images. A Docker repository can be compared more to a git repository in that sense.

  More specifically, repositories are location/name pairs that point to a set of specific filesystem layer identifiers.

  Repositories have names similar to a URL, so a repository identifier could be:

    quay.io/dockerinaction/ch3_hello_registry : version1

    RegistryHost/Username/ShortName:tag

  which points at layer:

          ---> 07c0f84777ef....


  Each repository contains at least one tag that points to a specific layer identifier and thus the image definition


  Repositories and tags are created with either:

    * docker tag;

    * docker commit;

    * docker build;

    []

  You can do that with the command <<<docker tag>>>

  Every repository contains a “latest” tag by default


**Registry

  A network provider of Image Repositories. e.g. Docker Hub Stores collections of repositories.


**Containers

  'Container' (previously Jail) has now become the preferred term to describe a modified runtime environment for a program which prevents said program from accessing protected resources.  i.e. think containment.

  “A container is a self-contained execution environment that shares the kernel of the host system and which is (optionally) isolated from other containers in the system.”

  Since you are sharing the machines kernel, there is relatively little additional technology between the isolated task and the real hardware underneath. For this reason, you can only run processes that are compatible with the underlying kernel. Usually this means Linux Kernels.

  When a process is running inside a container, there is only a very little shim that sits inside the kernel rather than potentially calling up into a whole second kernel while bouncing in and out of privileged mode on the processor.

  You can think of each of your Docker containers as behaving on the network like a host on a private network. The Docker server acts as a virtual bridge and the containers behave like clients behind it. (A bridge is just a network device that repeats traffic from one side to another).

  Each container has its own virtual Ethernet interface connected to the Docker bridge and its own IP address

  Typically, containers are created using either the run or create command:

---
  docker run -i -t ubuntu /bin/bash
---

  When you run this command, the following happens (assuming you are using the default registry configuration):

    [[1]] If you do not have the ubuntu image locally, Docker pulls it from your configured registry, as though you had run docker pull ubuntu manually.

    [[1]] Docker creates a new container, as though you had run a docker container create command manually.

    [[1]] Docker allocates a read-write filesystem to the container, as its final layer. This allows a running container to create or modify files and directories in its local filesystem.

    [[1]] Docker creates a network interface to connect the container to the default network, since you did not specify any networking options. This includes assigning an IP address to the container. By default, containers can connect to external networks using the host machine’s network connection.

    [[1]] Docker starts the container and executes /bin/bash. Because the container is running interactively and attached to your terminal (due to the -i and -t flags), you can provide input using your keyboard while the output is logged to your terminal.

    [[1]] When you type exit to terminate the /bin/bash command, the container stops but is not removed. You can start it again or remove it.

  The following illustrates the basic lifecycle of a container.

[./images/containerAndImageLifecycle.png]


====

*Building Images

  There are two general ways that can be used to create new images. Both use an existing image (often a 'Base' image) and supplement it with additional files or configuration in order to produce a more specialised one. The two methods follow the same principles. The first constructs the new image via a series of manual build steps; the second uses a build configuration file and tool support to automate the same basic steps.


**ImageTypes

***Base Images

  It the vast majority of cases, images will be built from base images. Often these will be little more than useful collections of linux shell commands and utilities. The object is often to keep them as small as possible: there is little point including software that won't get used in your software. Commonly used base images, all available from the Docker Hub registry include:

    * Busybox - about 750K compressed  (5Mb uncompressed). This combines many commonly used shell utilities into a single small executable. Busybox is often used in embedded systems etc.

    * Alpine - 2.6M compressed 5 M uncompressed. A highly stripped down version of linux.

    * Ubuntu - 25Mb (compressed). A popular unix distribution, stripped down to some degree.

    * Fedora - about 75Mb compressed. A popular unix distribution, stripped down to some degree.

    * Scratch - a special 'empty' image fro building images from nothing.

    []


  Other base images may be larger and more specialised in nature, for example:

    * java;

    * apache webserver;

    []

***Statically linked executables.

  Occasionally a base image can consist of just one file. An example might be a statically-linked executable. Such a executable has no externally dependedncies (libraries etc). Consequently it can execute directly on the kernel itself.


**Manual building of a new image.

  There are 3 basic steps to creating a new image:

 [[1]] Create a container from an existing image

 [[1]] Modify the filesystem of the container, by adding or changing files. These changes get written to a new layer in the union-filesystem of the container. These changes do not form part of the image from which the container is built, but are 'owned' by the container itself.

 [[1]] Commit the changes that you have made. Once committed, new containers can be created from the resulting image.


***Creating a container holding our base image

  To begin we need to have our base image running in a container in a way that we can connect to it and manipulate it. Here we are using a ubuntu image and are interacting with it via the bash shell.

---
  docker run -it --name baseImage ubuntu:latest /bin/bash
---

***Customize the base image

  Here, we shall just install git on top of our base image...

---
  apt-get update

    Get:1 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]
    Get:2 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
    Get:3 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]
    ...

  apt-get -y install git

    Reading package lists... Done
    Building dependency tree
    Reading state information... Done
    The following additional packages will be installed:
    ca-certificates git-man krb5-locales less libasn1-8-heimdal libbsd0 libcurl3-gnutls libedit2 liberror-perl libexpat1 libgdbm-compat4 libgdbm5 libgssapi-krb5-2 libgssapi3-heimdal libhcrypto4-heimdal
    libheimbase1-heimdal libheimntlm0-heimdal libhx509-5-heimdal libk5crypto3 libkeyutils1 libkrb5-26-heimdal libkrb5-3 libkrb5support0 libldap-2.4-2 libldap-common libnghttp2-14 libperl5.26 libpsl5
    libroken18-heimdal librtmp1 libsasl2-2 libsasl2-modules libsasl2-modules-db libsqlite3-0 libssl1.0.0 libssl1.1 libwind0-heimdal libx11-6 libx11-data libxau6 libxcb1 libxdmcp6 libxext6 libxmuu1
    multiarch-support netbase openssh-client openssl patch perl perl-modules-5.26 publicsuffix xauth
    ...
---
  What we have now is a container based on the baseImage, but whose container-owned top-level filesystem layer has been over-written by the files installed as part of git. These can be seen:

---
  docker diff baseImage

    C /tmp
    A /tmp/apt.conf.DjGWXN
    A /tmp/apt.data.8iSQ3p
    A /tmp/apt.sig.HOPS06
    C /bin
    A /bin/lessecho
    A /bin/lessfile
    A /bin/less
    A /bin/lesspipe
    ...
---
  As long as the container exists, these changes will persist. We can stop and restart the container and these changes will still be in effect:

---
  docker start --interactive baseImage

    # git version
    git version 2.17.1
---
  However we can create new containers with these changes and once the container is deleted, they will be gone for good. To persist those change, we commit them to a new image.


***Committing Changes to form a new image.

  The commit statement will create a new image. Here we we give it a repository name of gitimage, and add various elements of metadata.

---
  docker commit --author "KJC" --message "git Added" baseImage gitimage

  sha256:ab3fee460a49557acbaf061b65bbef6f703a5c47bd3ab0f125a7326ad0cc6386
---
  The new image can be seen listed amongst the images held locally to the docker server.

---
  docker images

    REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE
    gitimage                   latest              ab3fee460a49        40 seconds ago      186MB
    ubuntu                     latest              ccc6e87d482b        2 days ago          64.2MB
---
**The Commit

  When you use <<commit>>, you create a new layer to a docker image, and identify it in some meaningful way. As well as the filesystem, the commit also includes:

    * All environment variables

    * The working directory

    * The set of exposed ports

    * All volume definitions

    * The container entrypoint

    * Command and arguments

    []

  If these values weren’t specifically set for the container, the values will be inherited from the original image.

  We can now create a new container based on out new image.

---
  docker run -it --name gitimage gitimage /bin/bash

    root@5e04803107c4:/# git version
    git version 2.17.1
---

  An <<entrypoint>> is the program that will be executed when the container starts. Note how the entry point has been retained from the original image.

  If we want to change the entry point, say, to run git, we need to create yet another layer. (We could have done this all in the previous step, if we had chose to).

  Once again, create a container, but this time stating our entry point explicitly....

---
  docker run -it --name cmd-git --entrypoint git  gitimage

  usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]
  ...
---
  ...and once again commit our changes to a new image (gitimage)

---
  docker commit --author "KJC" --message "entrypoint now added" cmd-git cmdimage

    sha256:83ed5d3c08194db0fb86e13f66105f03762444dde146286328c2ffc3c0579149
---

  Now when we crate a container based on this image, our entry point is executed on startup

---
  docker run -it cmdimage

    usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
             [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
             [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
             [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
             <command> [<args>
---

  We can see the steps that have gone into making up an image with the <<<docker history>>> command.

---
  docker history cmdimage

    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    57b8e11dd34c        8 minutes ago                                                       0B                  entrypoint now added
    ab3fee460a49        About an hour ago   /bin/bash                                       122MB               git Added
    ccc6e87d482b        2 days ago          /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B
    <missing>           2 days ago          /bin/sh -c mkdir -p /run/systemd && echo 'do…   7B
    <missing>           2 days ago          /bin/sh -c set -xe   && echo '#!/bin/sh' > /…   745B
    <missing>           2 days ago          /bin/sh -c [ -z "$(apt-get indextargets)" ]     987kB
    <missing>           2 days ago          /bin/sh -c #(nop) ADD file:08e718ed0796013f5…   63.2MB
---

====
*Building Images with DockerFiles

  Rather than manually crafting the new image files as described above, it is usually better to make use of the <<<docker builder>>> facility. This utility takes a <<<Dockerfile>>> and processes it to build a new image in a predictable and reproducible way.

  Docker files are a simply text files containing a set of instructions using a particular syntax in order to construct an image.

  Each line in a Dockerfile represent a new commit point, and each commit point will create an intermediate image. These intermediate images will eventually layer up into the final image which is the overall build target of the Dockerfile.

  The intermediate images remain as images in their own right. Consequently, should one of the intermediate images need to be changed, it can effectively be swapped out and replaces WITHOUT having to build the layers on top or underneath.

**Anatomy of a Dockerfile

  The Docker build file needs to be called <<<Dockerfile>>>.

  It will lines that specify:

    * a Base Image

    * a series of Statements that layer files on top

    * any Environment variables to be set

    * Commands to be executed ( including, commands that will install additional packages ( e.g. apt-get, rpm, yum, dnf))

    * various Metadata items, such a s Maintainer, Labels etc

    []


**Dockerfile in the build process

  The <<<Dockerfile>>> is a simple text file making it amenable to version control. Maintaining multiple versions of an image is as simple as maintaining multiple Dockerfiles. It is usual that the Dockerfile used to build an image be maintained alongside the application's source code.

  The application build process would then make use of that Dockerfile producing the Docker image as the final build artefact.

**A simple DockerFile

  The following represents the Dockerfile that would be necessary to reproduce the same image that was earlier created manually.

---
  FROM ubuntu:latest
  MAINTAINER "KJC"
  RUN apt-get update && apt-get install -y git
  ENTRYPOINT ["git"]
---

  The builder works by automating the same tasks that you’d use to create images by hand. Each instruction triggers the creation of a new container with the specified modification. After the modification has been made, the builder commits the layer and moves on to the next instruction and container created from the fresh layer.

  The first instruction MUST be a FROM class (specifying the base image ( or 'scratch') if there is no base.) By default, the builder looks in the Docker server registry for the image. If not found there, they will be pulled from the Docker Hub (or other registry).

  The RUN statement is a command run on the current image (not the host machine) - fedora:latest in this case

  Each subsequent instruction implies a 'commit' and generates an intermediate image.


**Basic Dockerfile commands

  The following is a brief description of the most commonly used Dockerfile commands:

    The RUN instruction will execute any commands in a new layer on top of the current image and commit the results.

    There can only be one CMD instruction in a Dockerfile. The main purpose of a CMD is to provide defaults for an executing container. These defaults can include an executable, or they can omit the executable, in which case you must specify an ENTRYPOINT instruction as well.

    The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.

    The ENV instruction sets the environment variable <key> to the value <value>. This value will be in the environment for all subsequent instructions in the build stage

    The COPY instruction copies new files or directories from <src> and adds them to the filesystem of the container at the path <dest>.

    The ADD instruction copies new files, directories or remote file URLs from <src> and adds them to the filesystem of the image at the path <dest>. It also has the ability to take tar files as arguments: they will be untarred automatically inside the built image.

    An ENTRYPOINT allows you to configure a container that will run as an executable. Command line arguments to docker run <image> will be appended after all elements in an exec form ENTRYPOINT, and will override all elements specified using CMD

    The VOLUME instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers. When the container runs, external volumes will be mounted at these points.

    The USER instruction sets the user name (or UID) and optionally the user group (or GID) to use when running the image and for any RUN, CMD and ENTRYPOINT instructions that follow it in the Dockerfile

    The WORKDIR instruction sets the working directory for any RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in the Dockerfile

  For a fuller description of the options available, see the {{{https://docs.docker.com/engine/reference/builder/}Docker File Reference}}


**Invocation

  A docker build is initiated by "pointing" the process at the relevant build directory. The process expects to find a file, <<<Dockerfile>>>, that contains the required instructions to perform the build.

---
  docker build .

    Sending build context to Docker daemon  11.26kB

    Step 1/4 : FROM ubuntu:latest
    latest: Pulling from library/ubuntu
    5c939e3a4d10: Pull complete
    c63719cdbe7a: Pull complete
    19a861ea6baf: Pull complete
    651c9d2d6c4f: Pull complete
    Digest: sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110
    Status: Downloaded newer image for ubuntu:latest
     ---> ccc6e87d482b

    Step 2/4 : MAINTAINER "KJC"
     ---> Running in 9980b292c0e5
    Removing intermediate container 9980b292c0e5
     ---> e26057ab8b41

    Step 3/4 : RUN apt-get update && apt-get install -y git
     ---> Running in a38787d359cb
    Get:1 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]
    Get:2 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
    Get:3 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]
    Get:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB]
    Get:5 http://archive.ubuntu.c
    ...
    0 upgraded, 54 newly installed, 0 to remove and 1 not upgraded.
    Need to get 18.9 MB of archives.
    After this operation, 103 MB of additional disk space will be used.
    Get:1 http://archive.ubuntu.com/ubuntu bionic/main amd64 multiarch-support amd64 2.27-3ubuntu1 [6916 B]
    Get:2 http://archive.ubuntu.com/ubuntu bionic/main amd64 libxau6 amd64 1:1.0.8-1 [8376 B]
    Get:3 http://archive.ubuntu.com/ubuntu bionic/main amd64 libbsd0 amd64 0.8.7-1 [41.5 kB]
    Get:4 http://archive.ubuntu.com/ubuntu bionic/main amd64 libxdmcp6 amd64 1:1.1.2-3 [10.7 kB]
    Get:5 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 libxcb1 amd64 1.13-2~ubuntu18.04 [45.5 kB]
    Get:6 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 libx11-data all 2:1.6.4-3ubuntu0.2 [113 kB]
    Get:7 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 libx11-6 amd64 2:1.6.4-3ubuntu0.2 [569 kB]
    Get:8 http://archive.ubuntu.com/ubuntu bionic/main amd64 libxext6 amd64 2:1.3.3-1 [29.4 kB]
    Get:9 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 perl-modules-5.26 all 5.26.1-6ubuntu0.3 [2763 kB]
    Get:10 http://archive.ubuntu.com/ubuntu bionic/main amd64 libgdbm5 amd64 1.14.1-6 [26.0 kB]
    Get:11 http://archive.ubuntu.com/ubuntu bionic/main amd64 libgdbm-compat4 amd64 1.14.1-6 [6084 B]
    Get:12 http://archive.ubuntu.com/ubuntu bionic
    ...
    Setting up libxext6:amd64 (2:1.3.3-1) ...
    Setting up liberror-perl (0.17025-1) ...
    Setting up xauth (1:1.0.10-1) ...
    Setting up libldap-2.4-2:amd64 (2.4.45+dfsg-1ubuntu1.4) ...
    Setting up libcurl3-gnutls:amd64 (7.58.0-2ubuntu3.8) ...
    Setting up git (1:2.17.1-1ubuntu0.5) ...
    Processing triggers for libc-bin (2.27-3ubuntu1) ...
    Processing triggers for ca-certificates (20180409) ...
    Updating certificates in /etc/ssl/certs...
    0 added, 0 removed; done.
    Running hooks in /etc/ca-certificates/update.d...
    done.
    Removing intermediate container a38787d359cb
     ---> 44ce7f4f0b87

    Step 4/4 : ENTRYPOINT ["git"]
     ---> Running in 7c4c3a8708c6
    Removing intermediate container 7c4c3a8708c6
     ---> aba0c3d70a7d

    Successfully built aba0c3d70a7d
---
  We can see the downloaded base image and the newly crated image in the Dockers local registry, as follows. Note the image has no tag.

---
  docker images

  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
  <none>              <none>              aba0c3d70a7d        7 minutes ago       186MB
  ubuntu              latest              ccc6e87d482b        2 days ago          64.2MB
---
  We can tag the image explicitly

---
  docker tag aba0c3d70a7d dockerfile_git:1
---
  ...but it could have been tagged at the build stage

---
  docker build --tag dockerfile_git:1 .

  docker build -t example/docker-node-hello:latest .
---

**Dockerfile Best Practises

  {{https://docs.docker.com/engine/reference/builder/}}


Union File Systems

  A union filesystem is made up of <<layers>>. Each time a change is made to a union file system, that change is recorded on a new layer on top of all of the others. The “union” of all of those layers, or top-down view, is what the container (and user) sees when accessing the file system.

  When attempting to read a file, if that file was not created or changed on the top layer, the read will fall through the layers until it reaches a layer where that file does exist.

  The changes made to the filesystem of a container are listed with the docker <<<diff>>>.

  Most union file systems use something called copy-on-write, which is easier to understand if you think of it as copy-on-change.

  This has a negative impact on runtime performance and image size.

  All layers below the writable layer created for a container are immutable

  This property makes it possible to share access to images; instead of creating independent copies for every container. It also makes individual layers highly reusable.




Image Size

  If images evolved in the same way that most people manage their file systems, Docker images would quickly become unusable. Remember that actions like de-installing or removing files will still lead to the image size <<increasing>>; you are still just adding an extra layer.

  The union file system on your computer may have a layer count limit ( 42 a common max)

  You can examine all the layers in an image using the command: <<<docker history>>>

---
  docker history testimage2

  IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
  49a26c372390        41 minutes ago                                                      0B                  Entrypoint Added
  22d8cb633714        About an hour ago   /bin/sh                                         0B
  775349758637        5 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B
  <missing>           5 weeks ago         /bin/sh -c mkdir -p /run/systemd && echo 'do…   7B
  <missing>           5 weeks ago         /bin/sh -c set -xe   && echo '#!/bin/sh' > /…   745B
  <missing>           5 weeks ago         /bin/sh -c [ -z "$(apt-get indextargets)" ]     987kB
  <missing>           5 weeks ago         /bin/sh -c #(nop) ADD file:a48a5dc1b9dbfc632…   63.2MB
---

  You can flatten images if you export them and then reimport them with Docker. But that’s a bad idea because you lose the change history as well as any savings customers might get when they download images with the same lower levels

  The smarter thing to do in this case is to create a branch.

Branches

  The layer system makes it trivial to go back in the history of an image and make a new branch. So rather then taking the Application image and upgrading the Java installation from 6 to 7, it better to take the image PREDATING Java6 in the branch history and applying Java7 to create a new image, and THEN applying the Application Image to that.

  This is best achieved by using a Dockerfile to perform the build, rather than doing it manually.


[./images/dockerBranch.png]

*Building images from scratch

  This is sometimes necessary:

    * if you want an image that it stripped down to the bare minimum necessary to support your application;

    * if your layered filesystem has become too bloated, and it is necessary to flatten the stack of images down.

    []


*Building a stripped image

  Consider a statically linked executable  helloStatic

---
  tar -cvf helloStatic.tar helloStatic

  docker import -c "ENTRYPOINT[\"helloStatic\"]" someOwner/helloStatic -i helloStatic.tar
---


*Flattening

  The docker export command will stream the full contents of the flattened union file system of a <<container>> to stdout or an output file as a plain ordinary tarball. This can be manipulated in any way want

---
  docker export --output testimage2.tar tester4
---


  The docker import command will stream the content of a tarball into a new <image>

---
  core@core-01 ~/dockerFile $ docker import -c "ENTRYPOINT [\"/bin/sh\"]"  testimage2.tar testimage3
  sha256:cc51f24f7f640fb335f104ee936e1827f7c3d7aa060bb7c359c13a057d75db82
  core@core-01 ~/dockerFile $ docker history  testimage3
  IMAGE               CREATED              CREATED BY          SIZE                COMMENT
  cc51f24f7f64        About a minute ago
---

  There doe not seem to be way to explicitly layer images on top of each other. You can create an image, and base a container on it, but you can't explicitly place another pre-existing image on the top of it. Instead you add the native files on to the image and then commit the layer as described above.


Versioning

  It is considered good practice to represent incremental revisions of your repositories via sensible use of appropriate tags.   Every repository should have one tag that is completely static : once added it is never changed or removed.
  e.g. 1.1.1, 1.1.2 1.1.2,1.2.0 etc

  Repositories may optionally have other tags, which may be changeable. e.g. 1.1, 1.2 may be used to 'tag' the latest version on the 1.1.x or 1.2.x line.

  Particular care should be taken with the latest tag. Make sure that this always points at a stable build and NOT just the latest version. This is important because, if a tag is not explicitly stipulated, the one tagged lates is what is delivered.

  Consequently, always EXPLICITLY tag your latest STABLE repository as 'latest.'


Connecting to a running Docker...

---
  docker exec -it jenkins-tutorials bash
---





*Volumes




  /var/lib/docker/containers

  Every image id is gloablly unique.

  Image database, holding references to images that have been downloaded,  and references to the images that they are dependent upon
    /var/lib/docker/image/overlay2/imagedb/content/sha256
        ( shown by docker images -a)
    /var/lib/docker/image/overlay2/layerdb/sha256


  /var/lib/docker/overlays
    The actual images (including all dependencies)

    This are basically just ordinary directory / trees

      - Some will be very full ( base images may have a full unix filestem)

      - OR sparse ( just the changes that need to applied to a underlying base image)



    /var/lib/docker/containers
      When a container is created, it will reside here. Is little more than a couple of configuraration files..


    When a container is <run>

      3 extra filesystems mounted ( as seen by mount)

      overlay on /var/lib/docker/overlay2/099f9ca0b83c9a480c6f829730425a97699c79622938b6efb229b8a3c98ed25c/merged type overlay
        (rw, relatime, context="system_u:object_r:svirt_lxc_file_t:s0:c81,c85",
          lowerdir=/var/lib/docker/overlay2/l/PVJRN6WOLOQ3ZJFSQNUOTSI4G6
                  :/var/lib/docker/overlay2/l/RBKRGT2ZJU5S3ICE6J652O3L7E
                  :/var/lib/docker/overlay2/l/SRZ3ZWJRJVSNBKRPLELREFMUJ7
                  :/var/lib/docker/overlay2/l/MU4YFLVV6YV5HBVXLYHZOQPLYH
                  :/var/lib/docker/overlay2/l/4WOBSQQOI5GIZ6XJB3PDFTUTIE

          ,upperdir=/var/lib/docker/overlay2/099f9ca0b83c9a480c6f829730425a97699c79622938b6efb229b8a3c98ed25c/diff,
           workdir=/var/lib/docker/overlay2/099f9ca0b83c9a480c6f829730425a97699c79622938b6efb229b8a3c98ed25c/work
        )

            indicates the fs is created by layering up from the base image 4WOBSQQOI5GIZ6XJB3PDFTUTIE (which is a symolic link to the base image)

      shm on /var/lib/docker/containers/1e21bc3f518b82a11173948a4e3c94fdbf6b35511c55c1e7ae0587985f9f5238/mounts/shm type tmpfs (rw,nosuid,nodev,noexec,relatime,context="system_u:object_r:svirt_lxc_file_t:s0:c81,c85",size=65536k)

      nsfs on /run/docker/netns/617f7e07a354 type nsfs (rw)


      2 are visible in the filessytem  ( df -k)
      overlay          16326512 646360  14817656   5% /var/lib/docker/overlay2/08bfbe699434edd348948d0e12830343c13ed756f7eb5580e96618fa61cab409/merged

      shm                 65536      0     65536   0% /var/lib/docker/containers/4dfc1c25f3c3da5a464a043f4abc48e4d1962cc0c07d406cf276824107547587/mounts/shm

      nsfs                    0      0         0    - /run/docker/netns/66fe7f8485c7



      From the perpective of the container...

      overlay         16326512 646372  14817644   5% /
      tmpfs              65536      0     65536   0% /dev
      tmpfs             504640      0    504640   0% /sys/fs/cgroup
      /dev/sda9       16326512 646372  14817644   5% /etc/hosts
      shm                65536      0     65536   0% /dev/shm


      think of each of your Docker containers as behaving on the network like a host
on a private network, you’ll be on the right path. The Docker server acts as a virtual
bridge and the containers are clients behind it. A bridge is just a network device that
repeats traffic from one side to another.

  that each container has its own virtual Ethernet interface con nected to the Docker bridge and its own IP address


  CoreOs is a good Runtime envionemnt for docker. However, because ti is quite stripped down, it is not he best for learning. ()



 On systemctl based systems

---
  sudo systemctl enable docker


  sudo systemctl start docker
---




  Note that the docker executable is both the daemon and the command line interpreter all in one.

  The daemon DOES NOT have to be running in order to executer commands locally.

  However if it is running, then docker can be managed remotely, providing the relevant ports are open ( 2375)

  Although, can't get this to work!


  docker info
Client:
 Debug Mode: false

  Server:
  ERROR: error during connect: Get http://127.0.0.1:2375/v1.40/info: read tcp 127.0.0.1:49754->127.0.0.1:2375: read: connection reset by peer
  errors pretty printing info





Deploying a local Registry Server.

  The easiest way to run a docker registry is to run it itself in a container. The following will download and start a registry called 'registry' based on the Docker Hub image registry:2.

---
  docker run -d -p 5000:5000 --name registry registry:2
---

  The registry is now ready to use. By default, files will be stored on the machine hosting the docker container under <<</var/lib/docker>>>.  The location can be customized by specifing additional flags on teh command line etc.


*Starting the registry automatically

  If you want to use the registry as part of your permanent infrastructure, you should set it to restart automatically when Docker restarts or if it exits. This example uses the --restart always flag to set a restart policy for the registry.

---
  $ docker run -d -p 5000:5000 --restart=always --name registry registry:2
---

*By example

  [[1]] Start the registry server.

---
  docker run -d -p 5000:5000 --restart=always --name registry registry:2

    Unable to find image 'registry:2' locally
    2: Pulling from library/registry
    c87736221ed0: Pull complete
    1cc8e0bb44df: Pull complete
    54d33bcb37f5: Pull complete
    e8afc091c171: Pull complete
    b4541f6d3db6: Pull complete
    Digest: sha256:8004747f1e8cd820a148fb7499d71a76d45ff66bac6a29129bfdbfdc0154d146
    Status: Downloaded newer image for registry:2
    244b15723dd13131a7b546a83108a962500754759555d05e8eb667f7f520ae12
---
  [[1]] Download a test image from the Docker Hub Registry

---
    docker pull ubuntu:16.04

    16.04: Pulling from library/ubuntu
    0a01a72a686c: Pull complete
    cc899a5544da: Pull complete
    19197c550755: Pull complete
    716d454e56b6: Pull complete
    Digest: sha256:3f3ee50cb89bc12028bab7d1e187ae57f12b957135b91648702e835c37c6c971
    Status: Downloaded newer image for ubuntu:16.04
---
  [[2]] Tag it as part of the local repository.

---
    docker tag ubuntu:16.04 localhost:5000/my-ubuntu
---
  [[1]] Push it to our repository

---
    docker push localhost:5000/my-ubuntu

    The push refers to repository [localhost:5000/my-ubuntu]
    fa1693d66d0b: Pushed
    293b479c17a5: Pushed
    bd95983a8d99: Pushed
    96eda0f553ba: Pushed
    latest: digest: sha256:e60a002052d1a073f3212f3732cff8abc7997939c731850e6960eb94a244c406 size: 1150
---
  [[1]] Get rid of the image from our local docker registry

---
  docker image remove ubuntu:16.04

    Untagged: ubuntu:16.04
    Untagged: ubuntu@sha256:3f3ee50cb89bc12028bab7d1e187ae57f12b957135b91648702e835c37c6c971
    core@core-01 ~ $ docker image remove localhost:5000/my-ubuntu
    Untagged: localhost:5000/my-ubuntu:latest
    Untagged: localhost:5000/my-ubuntu@sha256:e60a002052d1a073f3212f3732cff8abc7997939c731850e6960eb94a244c406
    Deleted: sha256:96da9143fb1848141472255c4ae8b0b3885072a598921ab8e0793dc32a674f77
    Deleted: sha256:6728376ffa61b882948eebbc8f5d800989939f2108a8cce9e80366d3bec43515
    Deleted: sha256:ff4844ad26b52684c0d0767b1e3bc376eb51fcd2738cd5570be2e962234ed9ae
    Deleted: sha256:71e75970df43cfecc47852c90b0568b80f956bbe89bb3bef0de313e9ee56357b
    Deleted: sha256:96eda0f553ba9988a216cea7cf016d18d5f036677d411883b642c4c8c70e301b
---
  [[1]] Now pull back the image from our own repository

---
  docker pull localhost:5000/my-ubuntu

    Using default tag: latest
    latest: Pulling from my-ubuntu
    0a01a72a686c: Pull complete
    cc899a5544da: Pull complete
    19197c550755: Pull complete
    716d454e56b6: Pull complete
    Digest: sha256:e60a002052d1a073f3212f3732cff8abc7997939c731850e6960eb94a244c406
    Status: Downloaded newer image for localhost:5000/my-ubuntu:latest
---

*Running Docker Registry Securely.

  Running a registry only on localhost has only very limited usefulness. Normally the registry has to be accessible to external hosts. To do this, it must be secured using TLS, the successor protocol to SSL. (It does seem that the docker client executable will attempt communication on the http port 5000 when LOCAL, but use the https SECURE port 443, when attempting to contact remote machines.)

  The note {{{./onCertificatesAndKeyPairs.html}onCertificatesAndKeyPairs}} describes some of the background to TLS and how Keys and Certificates work within it.

  The steps to establish the necessary key and certificates are described below.


**Certificates needed to protect the Registry ports.

  [[1]] Generate a private key for use by our Docker Registry

---
  openssl genrsa -out ./serverKey.pem 2048

    Generating RSA private key, 2048 bit long modulus
    ......................................................................................................................................................+++++
    ...........+++++
    e is 65537 (0x10001)
---
  [[1]] Examine the contents of the certificate so generated and ensure all is on order:

---
  openssl rsa -text -in serverKey.pem

    Private-Key: (2048 bit)
    modulus:
        00:ba:2d:51:89:06:ba:1a:68:a5:6a:95:ca:0a:e8:
        32:9d:3d:06:77:8d:dd:c7:e0:99:c0:83:81:6f:33:
        e7:16:f4:5e:25:b6:58:80:56:fa:a3:2b:d9:b2:f1:
        0a:8b:54:c2:f4:6b:1f:7f:eb:5e:c5:d1:08:38:95:
        f5:7a:88:f9:de:3e:c6:7a:e0:67:0b:97:a1:76:46:
        82:45:24:01:63:e9:5b:e7:0c:7d:00:4f:bd:72:56:
        c3:c4:7a:0a:31:d2:b6:46:16:24:36:45:b6:27:73:
        2a:58:af:3e:d6:82:b7:42:20:7e:1a:22:86:9e:32:
        d5:f5:8e:cf:fa:89:b8:f9:9a:49:87:d6:f9:f3:3c:
        8b:4e:a5:98:82:e4:a9:a0:cf:37:8d:30:14:62:22:
        7f:d7:7b:d7:c5:85:7c:b9:bd:43:cb:5c:4e:dc:91:
        5b:dd:20:5e:5d:b3:0c:36:fa:c7:69:ed:f3:33:ce:
        f7:1d:85:22:1c:dc:d8:fb:53:c7:72:ae:00:75:1c:
        3f:73:ae:33:b2:17:63:40:3c:66:a5:aa:79:7d:bf:
        f0:86:b4:ff:5f:5b:26:88:56:32:ff:07:5d:cb:48:
        4e:c3:52:ea:6b:ce:d8:3e:f2:91:ad:d4:e7:d1:0f:
        ef:12:85:7a:01:50:87:01:67:bb:31:74:4e:80:b0:
        4a:2b
    publicExponent: 65537 (0x10001)
    privateExponent:
        58:fa:b3:cf:43:91:ca:71:5d:2d:95:ad:5c:8d:21:
        33:99:28:f0:16:b3:7a:85:d3:b5:f8:a3:f1:db:e2:
        84:4c:02:7b:0f:ad:38:99:59:6c:86:d6:a2:f9:24:
        ca:f6:95:be:6f:3c:3c:cc:e7:1c:b0:0c:b7:ce:a3:
        e6:0e:75:2d:4c:df:5b:76:c8:88:f7:cd:49:53:e5:
        8a:d9:ec:78:2d:dd:a8:8d:85:68:92:b3:be:63:cd:
        68:a7:d3:1b:80:d3:70:a7:c0:62:d7:ea:78:ec:47:
        be:de:f2:af:5f:05:ea:ea:d0:99:f9:0a:51:ad:86:
        28:b8:3a:9a:49:1c:48:de:2d:ac:21:7c:aa:51:11:
        8a:a8:68:94:e5:99:19:33:52:24:fa:ab:af:0b:c9:
        01:2e:d5:42:ed:ef:f0:09:6a:be:9c:fc:7d:25:8e:
        81:58:b7:3d:ab:b7:50:4b:0e:42:49:f7:1e:fe:ca:
        71:98:e9:5f:92:57:bd:e1:15:51:4a:f2:43:f8:35:
        c3:9f:a0:dc:30:87:a3:37:e7:69:f4:73:13:86:87:
        44:e4:24:0e:4a:82:78:6c:d3:18:9b:fe:14:1e:11:
        81:4c:d7:30:74:f6:7a:df:84:c2:be:5b:d7:78:5c:
        92:cb:d7:91:ba:09:48:99:92:48:53:8f:48:58:61:
        61
    prime1:
        00:df:b8:7c:61:80:85:03:ca:13:22:a1:a4:37:fc:
        0e:25:fd:d0:73:db:93:56:ec:0d:68:68:2a:ca:f1:
        57:df:7b:68:62:5f:77:ff:0c:86:8a:be:d8:76:0e:
        a1:fe:95:e1:d5:8e:25:ec:c5:65:af:7d:f8:de:2a:
        25:03:e7:70:66:83:d5:25:38:35:55:c6:7b:04:7c:
        d6:75:c3:05:7c:67:fc:9e:36:54:cc:c6:83:f6:aa:
        2e:6a:35:a8:29:09:70:99:a0:b2:2e:91:ee:2a:7f:
        5a:f8:a8:3b:81:48:89:fc:86:d0:49:6c:89:9b:42:
        57:ea:d5:63:1f:55:d5:88:03
    prime2:
        00:d5:0a:17:d8:ce:24:e7:64:30:bf:8e:fa:a9:54:
        3a:8b:28:73:49:49:9b:aa:14:9b:f0:89:0d:f9:58:
        e7:28:b6:9c:2a:ea:0c:0b:0b:07:70:bd:05:78:a7:
        02:f6:31:db:6c:c5:9a:0e:2e:b4:dc:97:0b:ef:91:
        ab:9f:ad:4d:e2:ca:66:fa:e1:a3:3b:8d:bd:21:30:
        4d:1f:3e:a4:8e:20:53:70:d2:2b:a7:1c:36:22:fa:
        af:7e:db:53:df:58:c0:34:61:5c:be:d0:c5:80:e1:
        09:6b:97:df:9a:6f:2f:4b:8e:f5:11:7a:44:39:41:
        66:86:25:e9:ba:35:cb:00:b9
    exponent1:
        2f:df:82:7e:3a:ca:3b:ed:59:fa:e7:2c:04:ee:e2:
        f8:2e:40:15:0a:bf:94:b2:1e:8c:60:fe:07:3f:6d:
        d6:5c:ca:11:82:ec:62:9f:83:8a:dd:1b:e4:e7:6c:
        b2:d5:cf:e5:aa:ed:62:a5:3b:05:3a:a7:ae:a2:c6:
        18:f7:c5:8d:aa:58:4a:06:a5:23:1d:bd:e5:4f:f1:
        74:71:af:12:d8:0d:ae:ad:61:a8:10:32:dc:ed:bd:
        d0:ec:7a:77:8d:95:92:ca:58:56:ae:d3:90:34:80:
        7b:05:44:f6:7d:57:49:ba:6f:87:c6:ba:0b:87:3e:
        d8:f9:a0:a4:6b:f1:ad:91
    exponent2:
        00:99:26:25:58:85:71:40:2a:e5:64:80:1b:b0:68:
        cd:a1:46:56:02:64:79:14:3e:b6:8f:a7:67:35:4e:
        74:f6:ee:b7:bb:9d:ff:44:5d:0c:5f:3e:73:55:75:
        f2:8a:1b:f3:5a:f1:7e:bb:1d:56:85:91:cc:51:cf:
        cd:a9:ff:83:13:3b:5f:e6:91:18:b0:72:47:79:39:
        68:e7:c2:37:b7:b8:83:63:82:a3:41:01:e5:e5:25:
        83:cd:d5:4c:29:2e:7b:15:ec:bc:28:ac:9a:9e:f8:
        a7:b6:02:3b:0b:a1:4c:45:ac:22:7f:0a:ff:4a:8d:
        ba:6f:4b:88:07:86:2e:46:79
    coefficient:
        7a:be:52:1e:08:37:90:0f:3b:12:62:0c:76:86:90:
        ed:d1:d2:62:07:d9:6d:cf:8f:79:e7:45:da:51:15:
        9d:3f:9b:7f:e9:61:30:77:b6:e6:4a:49:f7:1e:e7:
        2a:2d:41:dd:2d:f2:ba:53:3a:71:b4:87:5a:2b:e3:
        c4:ad:3a:1d:a6:05:68:ae:ed:91:57:0b:cd:b2:0e:
        4d:81:77:ba:43:4d:c5:e1:7d:b1:c7:fc:17:24:12:
        1d:7e:10:e1:57:96:29:86:2c:c7:2e:7b:fb:6e:9b:
        7b:d7:25:cb:72:2c:b3:62:55:8e:4b:a4:4f:8d:21:
        83:e0:45:a9:f4:32:a1:66
    writing RSA key
    -----BEGIN RSA PRIVATE KEY-----
    MIIEowIBAAKCAQEAui1RiQa6GmilapXKCugynT0Gd43dx+CZwIOBbzPnFvReJbZY
    gFb6oyvZsvEKi1TC9Gsff+texdEIOJX1eoj53j7GeuBnC5ehdkaCRSQBY+lb5wx9
    AE+9clbDxHoKMdK2RhYkNkW2J3MqWK8+1oK3QiB+GiKGnjLV9Y7P+om4+ZpJh9b5
    8zyLTqWYguSpoM83jTAUYiJ/13vXxYV8ub1Dy1xO3JFb3SBeXbMMNvrHae3zM873
    HYUiHNzY+1PHcq4AdRw/c64zshdjQDxmpap5fb/whrT/X1smiFYy/wddy0hOw1Lq
    a87YPvKRrdTn0Q/vEoV6AVCHAWe7MXROgLBKKwIDAQABAoIBAFj6s89DkcpxXS2V
    rVyNITOZKPAWs3qF07X4o/Hb4oRMAnsPrTiZWWyG1qL5JMr2lb5vPDzM5xywDLfO
    o+YOdS1M31t2yIj3zUlT5YrZ7Hgt3aiNhWiSs75jzWin0xuA03CnwGLX6njsR77e
    8q9fBerq0Jn5ClGthii4OppJHEjeLawhfKpREYqoaJTlmRkzUiT6q68LyQEu1ULt
    7/AJar6c/H0ljoFYtz2rt1BLDkJJ9x7+ynGY6V+SV73hFVFK8kP4NcOfoNwwh6M3
    52n0cxOGh0TkJA5Kgnhs0xib/hQeEYFM1zB09nrfhMK+W9d4XJLL15G6CUiZkkhT
    j0hYYWECgYEA37h8YYCFA8oTIqGkN/wOJf3Qc9uTVuwNaGgqyvFX33toYl93/wyG
    ir7Ydg6h/pXh1Y4l7MVlr3343iolA+dwZoPVJTg1VcZ7BHzWdcMFfGf8njZUzMaD
    9qouajWoKQlwmaCyLpHuKn9a+Kg7gUiJ/IbQSWyJm0JX6tVjH1XViAMCgYEA1QoX
    2M4k52Qwv476qVQ6iyhzSUmbqhSb8IkN+VjnKLacKuoMCwsHcL0FeKcC9jHbbMWa
    Di603JcL75Grn61N4spm+uGjO429ITBNHz6kjiBTcNIrpxw2IvqvfttT31jANGFc
    vtDFgOEJa5ffmm8vS471EXpEOUFmhiXpujXLALkCgYAv34J+Oso77Vn65ywE7uL4
    LkAVCr+Ush6MYP4HP23WXMoRguxin4OK3Rvk52yy1c/lqu1ipTsFOqeuosYY98WN
    qlhKBqUjHb3lT/F0ca8S2A2urWGoEDLc7b3Q7Hp3jZWSylhWrtOQNIB7BUT2fVdJ
    um+HxroLhz7Y+aCka/GtkQKBgQCZJiVYhXFAKuVkgBuwaM2hRlYCZHkUPraPp2c1
    TnT27re7nf9EXQxfPnNVdfKKG/Na8X67HVaFkcxRz82p/4MTO1/mkRiwckd5OWjn
    wje3uINjgqNBAeXlJYPN1UwpLnsV7LworJqe+Ke2AjsLoUxFrCJ/Cv9KjbpvS4gH
    hi5GeQKBgHq+Uh4IN5APOxJiDHaGkO3R0mIH2W3Pj3nnRdpRFZ0/m3/pYTB3tuZK
    Sfce5yotQd0t8rpTOnG0h1or48StOh2mBWiu7ZFXC82yDk2Bd7pDTcXhfbHH/Bck
    Eh1+EOFXlimGLMcue/tum3vXJctyLLNiVY5LpE+NIYPgRan0MqFm
    -----END RSA PRIVATE KEY-----
---
  [[1]] Generate a Certificate/Certificate Signing Request embedding the public key which pairs the Private Key generated for the server. These will be passed to client applications during the initial TLS handshaking.

---
  openssl req -new -key serverKey.pem -out serverReq.csr

    You are about to be asked to enter information that will be incorporated
    into your certificate request.
    What you are about to enter is what is called a Distinguished Name or a DN.
    There are quite a few fields but you can leave some blank
    For some fields there will be a default value,
    If you enter '.', the field will be left blank.
    -----
    Country Name (2 letter code) [AU]:GB
    State or Province Name (full name) [Some-State]:.
    Locality Name (eg, city) []:Leeds
    Organization Name (eg, company) [Internet Widgits Pty Ltd]:pegortech
    Organizational Unit Name (eg, section) []:.
    Common Name (e.g. server FQDN or YOUR name) []:IP:10.2.0.5
    Email Address []:

    Please enter the following 'extra' attributes
    to be sent with your certificate request
    A challenge password []:
    An optional company name []:
---
  [[1]] Once again, the content of the Signing Request can be examined.

---
  openssl req -text -in serverReq.csr -noout

    Certificate Request:
        Data:
            Version: 0 (0x0)
            Subject: C=GB, L=Leeds, O=pegortech, CN=IP:10.2.0.5
            Subject Public Key Info:
                Public Key Algorithm: rsaEncryption
                    Public-Key: (2048 bit)
                    Modulus:
                        00:ba:2d:51:89:06:ba:1a:68:a5:6a:95:ca:0a:e8:
                        32:9d:3d:06:77:8d:dd:c7:e0:99:c0:83:81:6f:33:
                        e7:16:f4:5e:25:b6:58:80:56:fa:a3:2b:d9:b2:f1:
                        0a:8b:54:c2:f4:6b:1f:7f:eb:5e:c5:d1:08:38:95:
                        f5:7a:88:f9:de:3e:c6:7a:e0:67:0b:97:a1:76:46:
                        82:45:24:01:63:e9:5b:e7:0c:7d:00:4f:bd:72:56:
                        c3:c4:7a:0a:31:d2:b6:46:16:24:36:45:b6:27:73:
                        2a:58:af:3e:d6:82:b7:42:20:7e:1a:22:86:9e:32:
                        d5:f5:8e:cf:fa:89:b8:f9:9a:49:87:d6:f9:f3:3c:
                        8b:4e:a5:98:82:e4:a9:a0:cf:37:8d:30:14:62:22:
                        7f:d7:7b:d7:c5:85:7c:b9:bd:43:cb:5c:4e:dc:91:
                        5b:dd:20:5e:5d:b3:0c:36:fa:c7:69:ed:f3:33:ce:
                        f7:1d:85:22:1c:dc:d8:fb:53:c7:72:ae:00:75:1c:
                        3f:73:ae:33:b2:17:63:40:3c:66:a5:aa:79:7d:bf:
                        f0:86:b4:ff:5f:5b:26:88:56:32:ff:07:5d:cb:48:
                        4e:c3:52:ea:6b:ce:d8:3e:f2:91:ad:d4:e7:d1:0f:
                        ef:12:85:7a:01:50:87:01:67:bb:31:74:4e:80:b0:
                        4a:2b
                    Exponent: 65537 (0x10001)
            Attributes:
                a0:00
        Signature Algorithm: sha256WithRSAEncryption
             63:06:31:fd:8c:dc:4e:10:70:b8:18:b0:2a:22:64:63:cc:70:
             f2:ec:80:96:68:a5:0f:b1:fb:c5:41:7b:99:ac:4d:4a:75:9c:
             43:67:c4:a6:f4:0a:b6:7f:19:61:f9:ef:4e:d0:aa:69:bd:d3:
             dd:ce:84:35:89:d7:23:8a:f5:87:d3:75:dc:53:a0:05:83:ff:
             b6:eb:67:78:87:8d:7a:b0:7d:83:1d:3b:64:9e:2d:77:67:aa:
             3a:40:47:c9:1e:21:5c:57:62:df:87:fd:d8:be:2a:4b:a3:29:
             30:81:32:64:00:77:98:d2:c9:34:83:fd:61:f3:52:b7:2d:74:
             b9:47:23:ec:0f:bd:4c:2d:78:27:5c:dd:c0:a6:6b:5e:ff:57:
             35:02:78:9a:25:a0:3e:f6:d0:02:ae:a4:08:d6:22:91:42:85:
             4c:15:a4:ae:4a:1c:50:8d:8c:c6:3e:79:75:46:9d:b8:df:d2:
             c8:c0:0f:b1:5c:b8:9e:8c:b6:d9:39:51:72:51:79:fa:2b:44:
             54:c9:11:f4:40:32:05:39:04:64:21:2f:c9:93:05:9d:90:82:
             87:ea:3a:b4:bc:11:d5:96:dd:9b:7e:1e:38:e7:69:63:2b:79:
             5c:b7:3e:eb:1a:1d:04:57:b4:ac:29:54:b1:ff:f5:ac:42:e2:
             5d:a1:fd:6e
---

  [[1]] Certificate Signing. To be usable, the certificate needs to be signed. In some circumstance, it is possible to use a certificate signed using the same private-key whose corresponding public-key forms part of the certificate. However, the Docker Registry does not seem to like this : it seems to pick up on the fact that the server Key was destined for other uses.

  An error message such as:

---
  x509: certificate signed by unknown authority (possibly because of "x509: invalid signature: parent certificate cannot sign this kind of certificate" while trying to verify candidate authority certificate "IP:10.0.2.15")
---
  is issued.

  Instead, we have to use a second CA type certificate in order to sign the serverCertificates.

  [[1]] Generate the Private Key that will be used to sign our Server certificates.

---
  openssl genrsa -out ./ca_key.pem 2048

    Generating RSA private key, 2048 bit long modulus
    ......................................................................................................................................................+++++
    ...........+++++
    e is 65537 (0x10001)
---

  [[1]] Generate the corresponding Public Key Certificate/CSR for our CA Private Key...

---
  openssl req -new -x509 -key ca-key.pem -out ca.crt

    You are about to be asked to enter information that will be incorporated
    into your certificate request.
    What you are about to enter is what is called a Distinguished Name or a DN.
    There are quite a few fields but you can leave some blank
    For some fields there will be a default value,
    If you enter '.', the field will be left blank.
    -----
    Country Name (2 letter code) [AU]:UK
    State or Province Name (full name) [Some-State]:Yorkshire
    Locality Name (eg, city) []:Leeds
    Organization Name (eg, company) [Internet Widgits Pty Ltd]:Pegor Technical Services
    Organizational Unit Name (eg, section) []:CA
    Common Name (e.g. server FQDN or YOUR name) []:.
    Email Address []:.
---

  [[1]] We can now use the CA key and Certificate to sign the Server certificates. Note that in this particular case, we are wanting to use the certificates on more then one machine: or more accurately we haven't decided yet on where we want to host the Registry, so are including more than one IP address in order to give us options.

  These IP addresses need to given as Subject Alternative Names (SANS) within the signed certificate. These values CANNOT be specified on the command line, and must be included in an external file. This has the structure:

---
  subjectAltName=IP:10.2.0.15, IP:10.0.2.15, IP:192.168.0.17
---

  The name of the file is then specified on the command line.

  [[1]] Sign the Server Certificates with out CA certificate This will generate a signed certificate for encrypting traffic from our client servers : server.crt

---
  openssl x509 -req -days 1000 -in serverReq.csr -CA ca.crt -CAkey ca-key.pem -extfile SANS.txt -out server.crt -CAcreateserial

    Signature ok
    subject=/C=UK/ST=Yorkshire/L=Leeds/O=Pegor Technical Services/CN=10.0.2.15
    Getting CA Private Key
---

  [[1]] Check the Signed Certificate over

---
  openssl x509 -text -in server.crt -noout

    Certificate:
        Data:
            Version: 3 (0x2)
            Serial Number:
                ae:67:18:28:3d:c1:c3:a8
        Signature Algorithm: sha256WithRSAEncryption
            Issuer: C=UK, ST=Yorkshire, L=Leeds, O=Pegor Technical Services, OU=CA
            Validity
                Not Before: Jan 21 22:20:13 2020 GMT
                Not After : Oct 17 22:20:13 2022 GMT
            Subject: C=UK, ST=Yorkshire, L=Leeds, O=Pegor Technical Services, CN=10.0.2.15
            Subject Public Key Info:
                Public Key Algorithm: rsaEncryption
                    Public-Key: (2048 bit)
                    Modulus:
                        00:a7:b7:41:3a:dc:85:c2:37:d7:13:74:5a:48:60:
                        c7:ac:17:69:5a:0c:dd:8e:f4:a5:04:c4:95:d0:50:
                        4a:ef:4f:fa:9c:ce:46:17:0b:4d:76:30:5e:3c:cf:
                        5b:ff:1e:e6:fb:fc:12:af:cc:e8:ef:0d:b2:da:b3:
                        bc:2c:c9:f1:e3:07:42:a0:25:dd:1d:d1:09:35:87:
                        39:1b:30:78:70:ef:97:7c:24:11:4e:2a:65:fa:66:
                        ed:68:57:9a:c6:84:91:a3:fb:7c:75:99:6a:b0:4d:
                        4a:5d:7e:71:0e:21:c0:f3:cb:5e:bc:5d:70:fd:c9:
                        f4:65:03:25:fe:cc:f6:43:99:d9:a7:d3:35:01:0a:
                        ca:8d:c3:59:d1:41:b4:d2:98:5f:33:85:92:a8:95:
                        2a:cc:a9:22:08:f6:3b:1e:98:5f:cd:e6:b4:4d:81:
                        90:62:9f:7f:2d:80:08:f8:ff:f7:2c:8c:1f:fe:cc:
                        b1:63:90:b1:c8:1f:8a:7f:de:01:a6:84:00:9e:39:
                        51:16:6c:ea:b5:3e:f9:25:29:08:f8:2d:52:e3:ef:
                        f1:a6:59:b1:70:c8:2a:e3:f0:1e:81:a7:5a:1a:f9:
                        77:41:74:68:96:64:4e:19:c7:97:ff:c2:3d:a8:67:
                        27:96:c5:3d:00:64:30:d7:39:0e:5b:95:8f:28:11:
                        1c:91
                    Exponent: 65537 (0x10001)
            X509v3 extensions:
                X509v3 Subject Alternative Name:
                    IP Address:10.2.0.15, IP Address:10.0.2.15, IP Address:192.168.0.17
        Signature Algorithm: sha256WithRSAEncryption
             31:0d:54:52:18:56:ed:48:84:0d:f2:2a:e1:ef:d6:a7:59:6d:
             6b:6e:8f:77:e2:fc:f8:e6:28:c8:4c:af:06:33:22:45:d3:f4:
             0f:7e:5d:71:43:34:78:15:52:d7:b3:4d:75:aa:84:a2:8e:3e:
             18:8b:7a:1a:72:4f:ab:05:df:0c:63:0b:26:fe:90:2c:d2:9d:
             f2:53:ab:ed:93:7e:c4:79:d7:c9:bc:39:d0:47:d9:e2:c0:1f:
             e2:e2:0b:e3:1c:97:58:6c:ea:0d:0a:8f:22:ca:df:4b:37:4e:
             f2:ad:bf:17:32:75:52:33:bf:e1:6c:e2:a9:2b:0d:ad:0a:e4:
             3c:0b:de:98:6e:9a:9e:db:1d:ac:93:5a:62:f9:8a:d4:6e:45:
             dc:10:b5:ef:ae:69:56:9a:78:7a:61:c7:f2:ec:31:ef:db:ea:
             03:6c:89:bb:2b:e5:3e:1f:d9:54:26:fb:4d:c7:c9:26:6a:c7:
             18:eb:86:c4:e4:be:fc:42:25:e8:29:37:9a:5c:7a:e6:09:15:
             7c:28:b2:a2:39:53:8c:0d:1c:9d:d9:d0:5e:ea:51:67:d0:68:
             99:87:00:ee:08:3c:de:52:76:a1:0b:22:60:af:b4:e3:d5:2e:
             da:61:17:c1:dd:d2:9c:70:90:6c:55:11:ff:22:ea:6f:ae:25:
             d9:8a:6b:04
---


**Configure Docker to use the certificates

  [[1]] If necessary, stop the running container

---
  docker container stop registry

    registry
---

  [[1]] Delete the existing container prior to its recreation

---
  docker ps -a

    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES
    86e9b62ec1e4        registry:2          "/entrypoint.sh /etc…"   About an hour ago   Exited (2) 18 seconds ago                       registry


  docker rm 86e9b62ec1e4

  86e9b62ec1e4
---
  [[1]] Recreate the container, providing the location of the certificates created above as parameters. These are the SERVER certificates NOT the CA ones.

  Note that we are choosing to run the registry on port 6443 so that we can map a port in from a Host operating system without issue.

---
  docker run -d --restart=always --name registry -v /home/core/ssl:/ssl -e REGISTRY_HTTP_ADDR=0.0.0.0:6443 -e REGISTRY_HTTP_TLS_CERTIFICATE=/ssl/server.crt -e REGISTRY_HTTP_TLS_KEY=/ssl/serverKey.pem -p 6443:6443 registry:2

    540956ae42565a194dbf694356a52288eb5345b0db4e915ff59dd06fb3a3e67d
---


**Testing the presentation of the Configured Certificates.

  We can check that the certificates are working as we would expect them using:

    * curl, or even better,

    * an openssl utility c_serial

    []

*** Testing with curl.

  Here we see that at the time of testing a self-signed certificate is in place.

---
  curl -v -X get https://10.0.2.15:6443

    Note: Unnecessary use of -X or --request, GET is already inferred.
    *   Trying 10.0.2.15:6443...
    * TCP_NODELAY set
    * Connected to 10.0.2.15 (10.0.2.15) port 6443 (#0)
    * ALPN, offering http/1.1
    * Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH
    * successfully set certificate verify locations:
    *   CAfile: /etc/ssl/certs/ca-certificates.crt
      CApath: /etc/ssl/certs
    * TLSv1.2 (OUT), TLS header, Certificate Status (22):
    * TLSv1.2 (OUT), TLS handshake, Client hello (1):
    * TLSv1.2 (IN), TLS handshake, Server hello (2):
    * TLSv1.2 (IN), TLS handshake, Certificate (11):
    * TLSv1.2 (OUT), TLS alert, unknown CA (560):
    * SSL certificate problem: self signed certificate
    * Closing connection 0
    curl: (60) SSL certificate problem: self signed certificate
    More details here: https://curl.haxx.se/docs/sslcerts.html

    curl failed to verify the legitimacy of the server and therefore could not
    establish a secure connection to it. To learn more about this situation and
    how to fix it, please visit the web page mentioned above.
---

***Testing with openssl utility

---
  openssl s_client -connect 10.0.2.15:6443

    CONNECTED(00000003)
    depth=0 C = UK, L = LEEDS, O = Pegor Technical Services, CN = IP:10.0.2.15
    verify error:num=18:self signed certificate
    verify return:1
    depth=0 C = UK, L = LEEDS, O = Pegor Technical Services, CN = IP:10.0.2.15
    verify return:1
    ---
    Certificate chain
     0 s:/C=UK/L=LEEDS/O=Pegor Technical Services/CN=IP:10.0.2.15
       i:/C=UK/L=LEEDS/O=Pegor Technical Services/CN=IP:10.0.2.15
    ---
    Server certificate
    -----BEGIN CERTIFICATE-----
    MIIDKjCCAhICCQDwMVwu0spvtjANBgkqhkiG9w0BAQsFADBXMQswCQYDVQQGEwJV
    SzEOMAwGA1UEBwwFTEVFRFMxITAfBgNVBAoMGFBlZ29yIFRlY2huaWNhbCBTZXJ2
    aWNlczEVMBMGA1UEAwwMSVA6MTAuMC4yLjE1MB4XDTIwMDEyMDIwNDAxMFoXDTIy
    MTAxNjIwNDAxMFowVzELMAkGA1UEBhMCVUsxDjAMBgNVBAcMBUxFRURTMSEwHwYD
    VQQKDBhQZWdvciBUZWNobmljYWwgU2VydmljZXMxFTATBgNVBAMMDElQOjEwLjAu
    Mi4xNTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALotUYkGuhpopWqV
    ygroMp09BneN3cfgmcCDgW8z5xb0XiW2WIBW+qMr2bLxCotUwvRrH3/rXsXRCDiV
    9XqI+d4+xnrgZwuXoXZGgkUkAWPpW+cMfQBPvXJWw8R6CjHStkYWJDZFtidzKliv
    PtaCt0Igfhoihp4y1fWOz/qJuPmaSYfW+fM8i06lmILkqaDPN40wFGIif9d718WF
    fLm9Q8tcTtyRW90gXl2zDDb6x2nt8zPO9x2FIhzc2PtTx3KuAHUcP3OuM7IXY0A8
    ZqWqeX2/8Ia0/19bJohWMv8HXctITsNS6mvO2D7yka3U59EP7xKFegFQhwFnuzF0
    ToCwSisCAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAswRfwDRjoImRfz2MiWYDwuql
    TFQ3joHNIYiHXR5Ils4xe2ArrBbitNW9lH8If8za7Ugs3PRAwtJFz8Kr4mwf0gd6
    GCGBMRnNdpo28gOAchjjBIG9LaEaJLPd4PuAaZchyKL5bOKVQmu6y5gXONStIqgD
    jn5TGoCSVgJvwZzyvxfyXqd9fxDPR79j7x7u6mNzASXyI093L71ENHj6wTUS13AK
    ZRUe0+4IMJkt/DYCTlDLj6aP+QS7XY9qKMdoidYbM4AVNA5nmuMjHXwjZ1DKBlP2
    ArEqXIO0Av0r3Gc5CGuP5ZSazp+t7h+pDJ2cxCpCBU3QgO1F3GXP+VzdkLDEZg==
    -----END CERTIFICATE-----
    subject=/C=UK/L=LEEDS/O=Pegor Technical Services/CN=IP:10.0.2.15
    issuer=/C=UK/L=LEEDS/O=Pegor Technical Services/CN=IP:10.0.2.15
    ---
    No client certificate CA names sent
    Peer signing digest: SHA512
    Server Temp Key: ECDH, P-256, 256 bits
    ---
    SSL handshake has read 1420 bytes and written 416 bytes
    ---
    New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
    Server public key is 2048 bit
    Secure Renegotiation IS supported
    Compression: NONE
    Expansion: NONE
    No ALPN negotiated
    SSL-Session:
        Protocol  : TLSv1.2
        Cipher    : ECDHE-RSA-AES128-GCM-SHA256
        Session-ID: E8CAE55F6D7031A388452BD52954164AE3676A66C1D998C87C488B2BAF1F8473
        Session-ID-ctx:
        Master-Key: 8DDEB9F4C33BEEA7DB3D79E781DE3AA9BB06D48796DB6CF0C63353C56A1EF85A81281BF548798F63AA3D84F0A66FA177
        Key-Arg   : None
        PSK identity: None
        PSK identity hint: None
        TLS session ticket:
        0000 - ce 8a 92 16 1e 07 5d e0-38 51 2d 99 67 dd 67 9b   ......].8Q-.g.g.
        0010 - bd f9 3d a1 c0 fb a9 2b-5b cd b9 21 c5 37 73 c6   ..=....+[..!.7s.
        0020 - 20 a1 c1 90 63 39 a7 6e-f1 b9 84 ab d8 db 3e 55    ...c9.n......>U
        0030 - 51 5f 50 ca 92 63 a5 c6-ed 3a fa b1 b2 6c d9 a8   Q_P..c...:...l..
        0040 - 1c d2 ec c5 20 0d 62 f4-d3 15 b6 6a 82 9d 90 d5   .... .b....j....
        0050 - ab 54 39 38 60 5f d3 e0-34 46 09 b1 58 06 ad e2   .T98`_..4F..X...
        0060 - 2e 56 29 90 8b bb ec 64-8b 3b 74 19 40 76 9c 1f   .V)....d.;t.@v..
        0070 - c0 d6 1f 6b cb 22 5f 23-                          ...k."_#

        Start Time: 1579554574
        Timeout   : 300 (sec)
        Verify return code: 18 (self signed certificate)
    ---
    HEAD / HTTP/1.0
    Host: 10.0.2.15

    HTTP/1.0 200 OK
    Cache-Control: no-cache
    Date: Mon, 20 Jan 2020 21:10:42 GMT

    closed
---


**Installation of CA public certificates

  In order for Client applications to validate the signatures on the certificates passed to it by Docker, the the clients will need access to the Public Key certificates of the Certificating Body. Once such client application is the docker client itself.

  If the docker client cannot validate the certificates, it will issue messages similar to:

---
    docker push 10.0.2.15:6443/my-ubuntu
    Error response from daemon: Get https://10.0.2.15:9443/v2/: x509: certificate signed by unknown authority
---
  The docker client requires the CA public key certificates (Not the server certificates) to a directory under <<</etc/docker/certs.d>>>. Here are the certificates used to to connect to <<<10.0.2.15:6443>>> are configured:

---
  sudo mkdir -p /etc/docker/certs.d/10.0.2.15:6443

  sudo cp ca.crt /etc/docker/certs.d/10.0.2.15:6443
---

*Pushing and Pulling to the local Repository

  In the example below, an image is pulled from the Docker Hub repository and then pushed to the local repository.

  [[1]] First pull an example image from the remote repository. The Docker Hub repository is used by default.

---
  docker pull ubuntu
---
  [[1]] Tag the downloaded image with the repository name and image new that you wish to use.

---
  docker tag ccc6e87d482b 10.0.2.15:6443/my-ubuntu
---

  [[1]] Now push it to the new repository.

---
  docker push 10.0.2.15:6443/my-ubuntu

    The push refers to repository [10.0.2.15/my-ubuntu]
    f55aa0bd26b8: Pushed
    1d0dfb259f6a: Pushed
    21ec61b65b20: Pushed
    43c67172d1d1: Pushed
    latest: digest: sha256:bc025862c3e8ec4a8754ea4756e33da6c41cba38330d7e324abd25c8e0b93300 size: 1152
---

*Networking Considerations when running the Registry within or alongside a Vagrant Cluster of VirtualBox Virtual Machines.

  Within a Vagrant environment, the VirtualBoxes can be connected to the Network in a number of different ways. The virtual network architecture determining ho those machines are connected, and where within the network the Docker Registry is sited, has implications for how Registry must be configured for access.

  A note, {{{./onVirtualBox.html#Networking with VirtualBox}describing Networking within VirtualBox}}, will give more details of this.

**With the Registry sited on a machine connected via a NAT interface.

  If your Registry is hosted on a virtual machine connected via a NAT interface, then that virtual machine is, by default, invisible and unreachable from the outside internet. The only way that you can make services such as the Registry available to the outside world is if you set up port forwarding.

  Port forwarding would make the Registry available to the outside world on a port mapped from the <<Virtual Machine HOST>>. e.g. 192.168.0.17:6443. All virtual machines running on both this host and others in the network generally, should be able to access the registry via this address.

  However, it does <<not>> seem to be possible to access the registry LOCALLY using this address. If you are actually logged on to the the machine hosting the registry, you need to access it using the local address, which, on a NAT connected machine, is usually 10.0.2.15.

  This is a bit of a pain: it's not particularly desirable to have to address the register differently depending on where you are.

***Port Mapping Restrictions

  Note that ONLY ports on the host above 1024 can be mapped (unless vagrant is running as root, which it generally shouldn't be). So we can cannot map the normal Docker Port 443 : we have to choose a unused host port such as 6443 and map that onto the port we are using for Docker

---
  e.g. host:6443 --> host:6443
---

  This has consequences for how we reference repositories within the registry. It is not possible to change the default registry that the docker client uses, so we need to supply the full specification when we are referencing repositories

    e.g. rather than pulling

---
      docker pull owner/repository:tag
---
    we would pull:

---
      docker pull 192.168.0.17:6443/owner/repository:tag
---
    which is a bit of a mouthful.

***Availability of the Certification Authority Public Key Certificates

  If the CA certificate used to sign the certificates protecting the secure port has not been issued by one of the standard ca bodies, then docker is not likely to have access to the necessary intermediate and root certificates needed to validate that signature.

  In order for docker to trust traffic secured in this way, the public-key certificates from the signing body need to placed within a a directory on each client machine.

---
    /etc/docker/cert.d./\<IP ADDRESS\>:\<PORT\>
---

**With the Registry sited on a machine connected on a HostOnly adapter

  If the Registry is installed to a server attached SOLEY to a HOST ONLY ADAPTER, then it will be available ONLY to the machines connected to the same HOST adapter i.e. virtual machines on the same host.

  It is still possible for the Registry to be available outside of the virtual machine cluster, but only if a NAT device is used in addition.

***Availability of the Certification Authority Public Key Certificates

  As with the NAT interface above, the CA certificates need to be installed to the client machines in order for the signatures on the TLS certificates to be validated.

**With the registry sited on a machine connected to a Bridged Interface.

  With the Registry sited on a machine connected to a Bridged Interface, it ought to be available ANYWHERE on the network.

  Additionally, it can be referenced with the same IP Address on any machine.
