JUnit5 and predecessors

*History

  JUnit5 is composed of modules from 3 different sub-projects:

    * JUnit Platform : is the foundation for the Testing Framework, and provides a command line launcher, and a JUnit 4 based runner to allow JUnit5 to run in a JUnit4 environment.

    * JUnit Jupiter : this is the new programming model and extension model for writing tests and extensions in JUnit5. It provides a <<<TestEngine>>> for running JUnit5 based tests on the platform.

    * JUnit Vintage : provides a <<<TestEngine>>> for running JUnit3 and JUnit4 based tests.

    []

  This {{{https://github.com/junit-team/junit5-samples}git project}} demonstrates how use Junit5 in a number of contexts.

=====
*Configuring into Maven

  Key dependency to include in your pom:

---
  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>${junit.jupiter.version}</version>
    <scope>test</scope>
  </dependency>
---

  JUnit Jupiter is the new programming model implemented by Junit5.


=====
*Framework Behaviour

  Junit runs as a Framework.  Classes that we create as test units that conform to the pattern required by the Framework will become registered as test classes within that framework and be manipulated by it.

  Typically, these classes will have a number of methods defined on them each designed to test some aspect of functionality of the object under test.

  During a test run, the framework will then instantiate instances of those classes and invoke their methods.

  The framework can be built into most popular build tools, including Maven, gradle, ant etc via specific product plugins.

  Both:

    * Maven Surefire - designed for running unit tests;

    * Maven FailSafe - designed for running integration tests;

  provide a jupiter engine.


=====
*Command Line Runner

  It is also available as a command line console. This takes the form of a Uber jar, ( i.e. containing all dependencies) and is available from Maven Central ( amongst) others.

  Have downloaded, to /usr/local/jar:

    {{{https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/1.5.2/junit-platform-console-standalone-1.5.2.jar}junit-platform-console-1-5-2.jar}}

  Looks as though using it might need a bit of working out though...


=====
*IDE Support

  Support is also built in to popular IDEs like Eclipse, Intellijet etc


=====
*Test Objects

  The framework recognises the classes and methods that are to be treated as test objects via the presence of particular annotations attached to the method/class. The basic test objects are:

    * Test Classes;

    * Test Methods;

    * LIfecycle methods.

  They are defined and recognised as follows:

**Test Classes

  A <<<Test Class>>>: is any top-level class, static member class, or <@Nested> class that:

    * contains a least one <<<Test Method>>>;

    * has a <<single>> constructor. (In previous versions of JUnit, constuctors were not allowed to have arguments, but that changed in Junit5);

    * is <<not>> be abstract.

    []

**Test Methods

   <<<Test Methods>>> are the actual tests themselves, and basically will either succeed of fail. A method will be treated by as a test method by the framework is it is <<annotated>> with either:

      * <@Test>:

      * <@RepeatedTest>

      * <@ParameterizedTest>

      * <@TestFactory>

      * <@TestTemplate>

      []

    Additionally, they must :

      * not be private;

      * not be abstract;

      * not return a value;


**Lifecycle Methods

  A <<<Lifecycle Method>>> method does not perform any testing itself, but are used in order to set up the test object prior to running a test,  or to tear down an object after a test. A method will be treated as a lifecycle method by the framework if it is annotated with either:

    * <@BeforeAll>;

    * <@AfterAll>;

    * <@BeforeEach>;

    * <@AfterEach>;

  Additionally, they must :

    * not be private;

    * not be abstract;

    * not return a value;


  How these fit into a standard Test Class is indicated below:

---
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {

  @BeforeAll
  static void initAll() {
  }

  @BeforeEach
  void init() {
  }

  @Test
  void succeedingTest() {
  }
  @Test
  void failingTest() {
    fail("a failing test");
  }

  @Test
  @Disabled("for demonstration purposes")
  void skippedTest() {
  // not executed
  }

  @Test
  void abortedTest() {
  assumeTrue("abc".contains("Z"));
  fail("test should have been aborted");
  }

  @AfterEach
  void tearDown() {
  }

  @AfterAll
  static void tearDownAll() {
  }
}
---


=====
*The Test Lifecycle.

  By default, the order in which test methods are executed is obscure (deliberately). It is still deterministic, in that repeating a suite of tests will run the tests in the same order; but, by default, Jupiter makes it deliberately difficult to predict (<@TestInstance(Lifecycle.PER_METHOD)>).

  However, if a test class/interfaces is annotated with a <@TestMethodOrder> annotation, then the user can choose to impose a particular order. (e.g. alphabetic order, sequential order, random order etc.)

  By default, and to allow individual tests to be executed essentially in isolation, Jupiter will create a NEW instance of each test class before it executes a test method, and then will destroy it immediately afterwards.

  If you wish to execute all tests on the SAME instance of an object, then the class can be tagged with the <@TestIntance(Lifecycle.PER_CLASS)> annotation. In this case <<ONE>> instance of the class will be created and all methods executed on this (possibly in a particular order if so annotated.)

  The basic lifecycle method are:

    * <@BeforeEach> : Denotes that the annotated method should be executed before each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class;

    * <@AfterEach> : Denotes that the annotated method should be executed after each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class;

    * <@BeforeAll> : Denotes that the annotated method should be executed just once before all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class. It only has any real usage when the PER_CLASS lifecycle is in force.

    * <@AfterAll> : Denotes that the annotated method should be executed just once after all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods have been executed in the current class. It only has any real usage when the PER_CLASS lifecycle is in force.

    []

  These are generally used to put the  object under test into the correct state for the test to proceed. This can be done with the individual tests themselves, but often several different test will wish to be initialised in the same way.


*Tests

**Repeated Tests

**Parameterised Test

  Parameterised Tests make it possible to run the same test multiple times, but with different arguments.



  In setting up the parameterised test, an argument source must be provided. Here you have several option:

    * @ValueSource  : Simplest form. Just provide the list of literal values you wish to use

        @ValueSources(ints = {1,2,3,4})

    * @NullSource and @EmptySource: provides a single null argument, or single empty argument to the test.

    * @EnumSource: Basically the test will be called for all values of a given Enumerator

    * CsvSource and @CsvFileSource

    * MethodSource : Allow you to define Factory methods that define a Stream of arguments. The test will be performed for each set of arguments in the stream.

    * ArgumentSource : Basically a class that implements the ArgumentSource Interface.




**DynamicTests



*Assertions

  Assertions is a collection of utility methods that support asserting conditions in tests.

  An assertion method is silent when its proposition succeeds, but throws an exception if the proposition fails. In general, if an assertion fails, method execution will not continue past that point and the test will fail.


  Unless otherwise noted, a failed <assertion> will throw an AssertionFailedError or a subclass thereof.

  If all assertions within a test method succeed then the test passes.

  The various assertTimeoutPreemptively() methods in this class execute the provided executable or supplier in a different thread than that of the calling code. This behaviour can lead to undesirable side effects if the code that is executed within the executable or supplier relies on ThreadLocal storage.

  The table below summarises the <assertion> functions that are available for use in testing. Although each function is shown only once, in reality each one is heavily overloaded to cope with input parameters of pretty much every type.

*--------------------+------------------------------------------------------------------------------------------+
| assertAll() | Assert that all supplied executables do not throw exceptions |
*--------------------+------------------------------------------------------------------------------------------+
| assertEquals() | Assert that expected and actual are equal. |
*--------------------+------------------------------------------------------------------------------------------+
| assertNotEqualsAssert() | Assert that expected and actual are not equal. |
*--------------------+------------------------------------------------------------------------------------------+
| assertArrayEquals() | Assert that expected and actual arrays are equal. |
*--------------------+------------------------------------------------------------------------------------------+
| assertIterableEquals() | Assert that expected and actual iterables are deeply equal. |
*--------------------+------------------------------------------------------------------------------------------+
| assertSame() | Assert that expected and actual refer to the same object. |
*--------------------+------------------------------------------------------------------------------------------+
| assertNotSameAssert() | that expected and actual do not refer to the same object. |
*--------------------+------------------------------------------------------------------------------------------+
| assertLinesMatchAssert() | that expected list of Strings matches actual list. |
*--------------------+------------------------------------------------------------------------------------------+
| assertNull() | Assert that actual is null. |
*--------------------+------------------------------------------------------------------------------------------+
| assertNotNull() | Assert that actual is not null. |
*--------------------+------------------------------------------------------------------------------------------+
| assertThrows() | Assert that execution of the supplied executable throws an exception of the expectedType and returns the exception. |
*--------------------+------------------------------------------------------------------------------------------+
| assertDoesNotThrow() | Assert that execution of the supplied executable does not throw any kind of exception. |
*--------------------+------------------------------------------------------------------------------------------+
| assertTimeout() | Assert that execution of the supplied supplier completes before the given timeout is exceeded. |
*--------------------+------------------------------------------------------------------------------------------+
| assertTimeoutPreemptively() | Assert that execution of the supplied supplier completes before the given timeout is exceeded. |
*--------------------+------------------------------------------------------------------------------------------+
| assertTrue() | Assert that the supplied condition is true. |
*--------------------+------------------------------------------------------------------------------------------+
| assertFalse() | Assert that the supplied condition is false. |
*--------------------+------------------------------------------------------------------------------------------+
| fail() | Fail the test |
*--------------------+------------------------------------------------------------------------------------------+

  Even though the assertion facilities provided by JUnit Jupiter are sufficient for many testing scenarios, there are times when more power and additional functionality such as matchers are desired or required. In such cases, the JUnit team recommends the use of third-party assertion libraries such as AssertJ, Hamcrest, Truth, etc. Developers are therefore free to use the assertion library of their choice.



  An example of the use of the most basic assertions is shown below.

---
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;
import example.domain.Person;
import example.util.Calculator;
import org.junit.jupiter.api.Test;


class AssertionsDemo {
  private final Calculator calculator = new Calculator();
  private final Person person = new Person("Jane", "Doe");

  @Test
  void standardAssertions() {
    assertEquals(2, calculator.add(1, 1));

    assertEquals(4, calculator.multiply(2, 2), "The optional failure message is now the last parameter");

    assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- " + "to avoid constructing complex messages unnecessarily.");
  }

  @Test
  void groupedAssertions() {
    // In a grouped assertion all assertions are executed, and all
    // failures will be reported together.

    assertAll("person",

      () -> assertEquals("Jane", person.getFirstName()),

      () -> assertEquals("Doe", person.getLastName())
    );
  }

  @Test
  void dependentAssertions() {
    // Within a code block, if an assertion fails the
    // subsequent code in the same block will be skipped.

    assertAll("properties",
      () -> {
        String firstName = person.getFirstName();

        assertNotNull(firstName);

        // Executed only if the previous assertion is valid.
        assertAll("first name",

          () -> assertTrue(firstName.startsWith("J")),

          () -> assertTrue(firstName.endsWith("e"))
        );
      },

      () -> {
        // Grouped assertion, so processed independently
        // of results of first name assertions.

        String lastName = person.getLastName();

        assertNotNull(lastName);

        // Executed only if the previous assertion is valid.
        assertAll("last name",
          () -> assertTrue(lastName.startsWith("D")),

          () -> assertTrue(lastName.endsWith("e"))
        );

      }
    );    //Assert All
  }

  @Test
  void exceptionTesting() {
    Exception exception = assertThrows(
      ArithmeticException.class,
      () -> calculator.divide(1, 0)
    );

    assertEquals("/ by zero", exception.getMessage());
  }

  @Test
  void timeoutNotExceeded() {

    // The following assertion succeeds.
    assertTimeout(
      ofMinutes(2),
      () -> {
        // Perform task that takes less than 2 minutes.
      }
    );
  }

  @Test
  void timeoutNotExceededWithResult() {

    // The following assertion succeeds, and returns the supplied object.
    String actualResult = assertTimeout(
      ofMinutes(2),
      () -> {
        return "a result";
      }
    );
    assertEquals("a result", actualResult);
  }

  @Test
  void timeoutNotExceededWithMethod() {

    // The following assertion invokes a method reference and returns an object.
    String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);

    assertEquals("Hello, World!", actualGreeting);
  }

  @Test
  void timeoutExceeded() {
    // The following assertion fails with an error message similar to:
    // execution exceeded timeout of 10 ms by 91 ms

    assertTimeout(
      ofMillis(10),
      () -> {
        // Simulate task that takes more than 10 ms.
        Thread.sleep(100);
      }
    );
  }

  @Test
  void timeoutExceededWithPreemptiveTermination() {
    // The following assertion fails with an error message similar to:
    // execution timed out after 10 ms

    assertTimeoutPreemptively(
      ofMillis(10),
      () -> {
        // Simulate task that takes more than 10 ms.
        Thread.sleep(100);
      }
    );
  }

  private static String greeting() {
    return "Hello, World!";
  }
}
---

*Assumptions

  Assumptions is a collection of utility methods that support <<conditional>> test execution based on assumptions.

  In direct contrast to failed <assertions>, failed <assumptions> do <<not>> result in a test failure; rather, a failed assumption results in a test being <<aborted>>.

  Assumptions are typically used whenever it does not make sense to continue execution of a given test method — for example, if the test depends on something that does not exist in the current runtime environment

  The table below summarises the <assumption> functions that are available for use in testing. Although each function is shown only once, in reality each one is heavily overloaded to cope with input parameters of pretty much every type.

*---------------------------------+----------------------------------------------------+
| assumeFalse​(boolean assumption) | Validate the given assumption. |
*---------------------------------+----------------------------------------------------+
| assumeTrue​(boolean assumption) | Validate the given assumption. |
*---------------------------------+----------------------------------------------------+
| assumingThat​(boolean assumption, Executable executable) | Execute the supplied Executable, but only if the supplied assumption is valid. |
*---------------------------------+----------------------------------------------------+


Miscellaneos Annotations

  * @Disable

  * @DisplayName

    This is more useful than it sounds. It allows a specific description to be displayed in test reports etc rather then the test/classs and test method name which cna be a bit cryptic.

  * @DisplayNmaeGenerator : basically allows a display name to be generated from the anme of the test class/method.


HamCrest Functions



The General Test Process

  arrange : creation of all Objects (except the Subject under Test) that are necessary for test execution

  act : execution of the Subject-under-test methods

  assert : verification of test results.


  Be a little wary Assumptions. Intuitively, these check the pre-conditions prior to execution. Remmeber that if the pre-conditions are NOT satisfied, then the test cannot be evaluated, and it will result in the trest being skipped. This can be harder to spot than if the test fails outright. Consequently consider using an Assertion rather then an Assumption.


*Beware the Hashcode

  Two object that are different can legitimately have the same Hashcode.

  Two objects that are .equal() SHOULD have the same hashcode, but that relies on the Class designer ENSURING that it is so. (i.e. obeying the general contract)





Dependency Injection for Constructors and Test Methods.

  Prior to V5, constructors and test methods were not permitted to have parameters. This has changed in in the Jupiter (v5) implemention, so providing the capabilty to inject dependencies, or just straight parameters,   into occur test classes.


  This is achieved via a custom object (one that implements ParameterResolver), which is registered within our test class. The framework will invoke methods on this object in order to inject the required Object (or data) into our test class.

  Generally resolvers work on the basis of three pieces of information:

    on the basis of the NAME given to the argument
    on the basis of the Type of the Object
    on the basis of an Annotation attached to the Method, or Parameter.

  I will describe an Annotation based resolver, which seems the most flexible, but ones working on the basis of name/type will work on a similar principle.


Define a Annotation to use to mark your injected parameter.

  This bit is not covered too well in the Documentation, and it took me a while to figure it out.

  The annotation must be defined with certain properties other wise it will be completely ignored by the test Runner. Examples below show annotations that can be used against a Parameter and a method (which are likely to the commonest uses.)

  For a method annotation:

---
  package junitTest.tests;

  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;

  @Target(value= {ElementType.TYPE,ElementType.METHOD})
  @Retention(RetentionPolicy.RUNTIME)
  public @interface methodAnnotation {
		   String name();
}
---

  and for a parameter annotation:

---
  package junitTest.tests;

  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;

  @Target(value= {ElementType.TYPE, ElementType.PARAMETER})
  @Retention(RetentionPolicy.RUNTIME)
  public @interface parameterAnnotation {

  }
---

  Note the Target and Retention parameters are vital. If they are not there, they will not work.

Define your Parameter Resolver

  Your parameter resolver is a custom object that implements the ParameterResolver interface. This interface has 2 methods:

---
    boolean supportsParameter(...)

    Object resolveParameter(...)
---

  supportsParameter() returns a boolean  which the test Framework will use to determine whether the ParameterResolver can be used to supply a particular parameter.

  resolveParameter is called to generate the actual value to inject.

  A typical resolver is shown below

---
  package junitTest.tests;

  import java.lang.annotation.Annotation;

  import org.junit.jupiter.api.extension.ExtensionContext;
  import org.junit.jupiter.api.extension.ParameterContext;
  import org.junit.jupiter.api.extension.ParameterResolver;
  import org.junit.platform.commons.util.ReflectionUtils;

  public class TestClassConstructorResolver implements ParameterResolver {

	@Override
	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
		// We invoke parameterContext.isAnnotated() instead of parameterContext.getParameter().isAnnotationPresent()
		// in order to verify support for the convenience method in the ParameterContext API.
		//return parameterContext.isAnnotated(TestClassConstructor.class);
	  return parameterContext.isAnnotated(parameterAnnotation.class);
}

	@Override
	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
		//return ReflectionUtils.newInstance(parameterContext.getParameter().getType());
		return "tester";
	}

}
---

  ParameterContext is the most useful Object in determining whether the ParameterResolver is useful in a given context. It contains a bunch of metadata describing the parameter that Resolver is attempting.

  Here the parameter is queried to see whether it has been decorated with the  parameterAnnotation annotation, as below:

---

  @Test
  final void testAdd(@parameterAnnotation String name) {
  assertEquals(name, "tester");
  }

---

  and, if it does, in this simple case it returns a simple string.

  For more complicated objects, the ReflectionsUtil factory method or some other such factory method can be used to construct and return the necessary object for injection into the method/constructor.

  Other descriptive pieces of information about the parameter can also e used to determine applicability ( name, type, enclosing method, enclosing class). Or, indeed, any combination of these.

Register your ParameterResolver with your Test Object

  This is a simple matter of annotating the appropriate item within your test class as shown below:

---
  @ExtendWith(TestClassConstructorResolver.class)
  class CalculatorTest2 {

	   public CalculatorTest2(@parameterAnnotation String name){

     ...

   }
---

    alternatively an individual method within the class can be annotated, and so the scope of applicability reduced.






Built in Extensions

  These replace @rules under JUnit4






Gotchas

    Be careful not to specify TWO test annotations, e.g.

      @Test
      @ParameterizedTest

    This can lead to the intended one being ignored, and an error message that is not particularily indicative of the cause of the failure.
