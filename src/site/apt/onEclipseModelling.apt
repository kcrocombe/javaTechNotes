Modelling in Eclipse using the EMF framework.


Index

  * {{{./onEclipseModelling/siriusDiagrammingTool.html}Diagramming with the Sirius Diagramming Tool.}}

	* {{{./onEclipseModelling/basicModelTransformation.html}Understanding the transformation of the model into code.}}

	*	{{{./onEclipseModelling/generatingDocumentation.html}The Eclipse Model Generator and JavaDoc.}}

	* {{{./onEclipseModelling/modellingGenerics.apt}Modelling Generics within EMF.}}

	* {{{./onEclipseModelling/generatingTestClasses}Generating JUnit Test Classes.}}


Some Useful Documentation

		{{https://www.eclipse.org/ecoretools/doc/index.html}}

		{{http://cedric.brun.io/eclipse/ecore-design-checklist-part1/}}

		{{http://cedric.brun.io/eclipse/ecore-design-checklist-part2/}}

		{{http://cedric.brun.io/eclipse/ecore-design-checklist/}}

		{{https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/package-summary.html}}




*Data Model

	A description of the ecore Model structure is available at {{{https://download.eclipse.org/modeling/emf/emf/javadoc/2.5.0/org/eclipse/emf/ecore/package-summary.html}org.eclipse.emf.core}}


*Creating a Modelling Project.

	The

		New 'Ecore Modelling Project'


	Choose the Viewpoints to Enable within the project. Different Viewpoints give you access to different representations of the models.

		Design - You definitely want this one.

		Other Viewpoints are:

			Archetype:

			Review:

			Generate:

	You can activate other viewpoints retrospectively:

		Right Click on Project --> Viewpoint Selection


	This creates 3 Models under the model folder:

		\<projectName\>.aird
		\<projectName\><<<.ecore>>>
		\<genModel\>.genmodel


	Underneath the 	\<projectName\>.aird, the hierarchy appears:
		Representations per Category
			Design
				Entities in a Class Diagram
					<Diagram Name>

	This diagram needs to be opened with the
		Sirius Diagram editor



*Other Stuff

	[[1]] Getting the implementation of a class to additionally implement an Interface not specifically modelled on the diagram

		add an @implement annotation into the user-doc section of the generated java code:

---
	 /**
 	 	* <!-- begin-user-doc -->
		* An implementation of the model object '<em><b>My User Profile Mesg</b></em>'.
		*
		* @implements com.garmin.fit.UserProfileMesg NOT
		*
		* <!-- end-user-doc -->
		*/
---

		You can do likewise with @extends, ( although since the generated class always will probably be forced to extend one of the standard Ecore classes, then, (since a class can only extend a single superclass),this seems to be of limited value.)

		I DO NOT THINK this ends up in the model files anywhere: I think it must be read from the java source files following regeneration - not absolutely sure on this however.





Delegating and Forwarding


		I have yet to find a way of sensibly using an actual concrete CLASS on the diagram that can be sensibly handled by the Code generator.

	[[1]] The graphical editor has a few Annoying Foibles:

		[[a]] If you amend stuff on the various Dialog boxes that pop up if you double click on an Item, then the changes do not take if you press 'OK' without moving out of the field you have just edited. You basically need to move the focus out of the edited field before pressing RETURN. Very Annoying.

		[[b]] If you give Instance Class Name to a Class/Interface (thereby turning it into a proxy for an external class), then if you change your mind, and try and delete it then it doesn't work too well. Even though the field is empty it treats it as being modelled by an external Null Class []. You need to use a different editor to correct this (edit the <<<ecore>>> model file with the <<<ecore>>> Editor).


	It is generally easier to refine items in the <<<ecore>>> Editor once the basic Classes and Relationships have been
	modelled graphically.



	[[1]] Generating Failing with Unhandled Exceptions.

		Occasionally these occur during generation. I THINK it happens when you change the name of an entity and regenerate.

		It generally can be fixed by deleting the previously generated java files, HOWEVER be careful to save any custom code in these FIRST!

		Shutting down and restrating Eclipse often helps here too.






		[[1]] Constructors and Factory Methods

	If you are running in the default configuration (Generating Interfaces and Implementing Classes), do not attempt to create explicit constructors on the diagram : in the context of a interface, they don't work.


	I feel there ought to be a way of getting the thing to generate more than just the default constructor...but if there is I haven't worked it out yet!

Backing out changes to Java Source.

	[[1]] The editor automatically keeps a history of all incarnations of source code files it generates. There is also a really good tool for comparing files in the History to the current file. It also supplies really good support for back porting any text changes that you might want to back out.



	[[1]] Representing Specific Generics, especially Collections, Lists etc

	The modelling tool seems to provide a limited range of generic collections:
		EEList<T>      --> org.eclipse.emf.common.util.Elist
		EMap <K,V>		--> java.util.Map
		ETreeIterator<T> --> org.eclipse.emf.common.util.TreeIterator

		If you want use a specific external class in your mode, the obvious way would seem to define an Datatype much as you would for other external Classes. However this does not seem to work too well.

		e.g.

		Name:						 IterableOfSomeClass
		Instance Class Name:  java.lang.Iterable
		Instance Type Name:   java.lang.Iterable<SomeOtherclass>

		This looks like it SHOULD work. However, in practise, this seems to get translated in the code to:
		Iterable<Object>
		and not
		Iterable<SomeOtherClass>


		However, it does seem to posssible to represent the required Collection as an Interface instead

		Name:						 IterableOfSomeClass
		Instance Class Name:  java.lang.Iterable
		Instance Type Name:   java.lang.Iterable<SomeOtherclass>

		Abstract: True
		Interface: True

		This DOES seem to get translated in the code as
		Iterable<SomeOtherClass>

=====

Modelling a Top Level Application class with a main() method.

	When modelling an actual application from a collection of Classes, it seems to me (perhaps naively), that there is some conceptual value to creating a simple Class which collects together the major Objects that the application will use to form some sort of Application State.

	Generally the class would a containing class for these other objects.

	This provides:

	  	a means by which constraints between the major objects can be expressed;

			a home for the main() function.


	i.e. modelled (in text) something like:

---
	Application::
			ClassA : attrA
			ClassB : attrB

	public static void (main args[]){};
---


	Java requires that the main function have the signature:

---
	public static void (main args[]){};
---

	This constrains the way that the model can be represented. The main method is static, i.e. it can be called by referencing the Class directly, WITHOUT needing any underlying object. This means it can't access any other member attributes/functions that are not themselves static.

	Obviously it is likely that our main method WOULD want to reference attribute attrA, attrB etc. not least, to initialise them (Remember the main() method WILL be executed before ANY constructors)

	In a situation when where we are manually coding, typically we would get round this need this to be represented in code in one of 2 ways:


Approach 1

	Ensure that the attrA and attrB are themselves static, e.g.

---
		class Application {

			static ClassA attrA;
			static ClassB attrB;

			private static void main( String args[]) {
				attrA = new ClassA();
				attrB = new ClassB();
				...
			}
		}
---

	In a ecore modelling envionment, this is problematic; you can't specify in the modelling tool that you want particular member attributes to be static. You would have to include them as non-generated attributes/methods and ideally to get the most out of the tool, we want to minimise this.


Approach 2

	Create an instance of our Application Class within main, and then manipulate its variables. This looks a bit strange, because it we are defining an instance of Application within the Application class itself, but this is a pretty standard approach.

---
		class Application {

			ClassA attrA;
			ClassB attrB;

			private static void main( String args[]) {

				Application app = new Application();

				app.attrA = mkClassA();
				app.attrB = mkClassB();
				...
			}
		}
---

	In the above, we are using Factory Methods rather than constructors for ClassA and ClassB, but the approach works for both.

	In the ecore modelling environment, this works pretty well. The one aspect that has to be manually crafted is the main() function itself. This has to have the signature

---
		public static void main( String args[] ) {..}
---

	and I haven't found a way (yet) of generating this out of the model.

	If you wanted to put everything into the model, it is pretty straightforward just to delegate the work that might have been done with main() to a second function ( run() in our example below).

	All the main() function has to do is create and instance of the Class and invoke its run() method.

---
		@generated NOT
		static public void main(String args[]) {

	 		Application app= new ApplicationImpl();

	 		app.run(args);
	 	}
---

	The run() method can then do the rest.


Factory Methods rather than Constructors

	One of the things the code generator does for you is build a factory method for every class defined in your package. A factory method is just a method that returns a fully formed instance of your class.

	When handcrafted, these are often created as static method, so you don't need an existing object to invoke them. However, our auto-generated factory methods are plain, public methods on a xxxxFactory class. We get one xxxxFactory class for each package (xxxx).

	Factory methods have several advantages over constructor, and the reader is referred to Effective Java for a description of these.

	 	- unlike constructors, they have names, so can be named according to the what you want them to do.

		- the names don't change if we decide to change the classes by which we implement

		- different factory methods, can have identically typed parameters

		- they are not required to create a NEW object each time. You can force them to return a pre-existing object.

		- they can return any SUBTYPE of their stated return type, and indeed the return type can vary based on the parameters of the call.


	So our example above, assuming a package name Package:

---
		@generated NOT
		static public void main(String args[]) {

	 		Application app= new PackageFactoryImpl().createApplication();

	 		app.run(args);
---

	and much like a constructor, we would use createApplication() to shape what we want our object to look like when it is initialised:

---
		public Application createApplication() {
			ApplicationImpl app = new ApplicationImpl()

	 		PackageFactory factory = new PackageFactoryImpl();

			app.attrA = factory.createClassA();
			app.attrB = factory.createClassA();

		}
---




The Generated constructors and Factory Methods

	By default, the generated constructors are:

		PROTECTED : so can only be invoked by Sub-classes and Other Elements in the same package.

	While the generated factory methods are PUBLIC.

	This means that the clients from OTHER packages are forced to use the factory methods ( which is good), but allows other Classes from within our package to by-pass the factory methods and GO direct.

	We want to discourage this because factory methods make it easy to change the actual class implementing a piece of functionality just my getting the factory method to return a different Class instance ( remember the return signature of a factory method specifies the interface a Class must implement NOT the class itself.)

	If we wanted to lock the constructors down further, we can; but it has its inconveniences:

		We can't easily change this to PRIVATE because this would lock out the Factory Methods, which sit in a <<different>> class in the same package. We would need to create our own factory method in the same class as the constructor. This is do-able but inconvenient.

		We can change it to PACKAGE: i.e. accessible to other members of the package but not anything which sub-classes it, so we CAN tighten it further if that is required.

	Note that changing the signature on the generated methods (private, protected) etc. is fine providing we remember to mark it as @Generated NOT


Location of the Logic for Object Building

	Given the co-existence of Constructors and Factory methods, we have a choice as to where we place the logic.

	My feeling is that this should STIll be in the constuctor. THis is becuase:

		- it keeps the logic within the Class itself which I think its important. It means the class is responsible for ensuring its own integrity.

		- it minimises the risks, should something manage to bypass the factory methods and create an object directly.

		- it is more visible

	Instead, I think the Factory methods should be principly for:

		- giving more meaningful names where certain speciality objects are reuired

		- BEING THE SOLE PLACE WHERE ACTUAL IMPLENTATION OF A PARTICULAR INTERFACE IS CONFIGURE. Ideally, we can change an application to use implementation B of an Interface rather than implementation A just by amending the factory method so it returns implemention B rather than A.




	This is the method that will work best

	USe the Factory Methods


So:

		1.  Don't put the main() function in the model.   It can't be generated properly

		2. I cannot find a way to make CodeGen generate class attributes as static. Therefore, we cannot use Approach 1 without disabling the generation of this part of the model.

		3. It is probably better to use Approach 2.



Implementing Singleton Classes

	A singleton class is one where just a single instance is allowed.

	It seems to be relatively easy to implement this feature WITHOUT having to actually model anything; it acn all be done in the implementing class.

	The following seems to be a relatively standard way of doing it ( From Effective Java).

	It needs :

		1. a public static final field to hold and instance of itself;

		2. A private constructor.

---
	public ClassImpl {
		public static final ClassImpl SINGLETON = new ClassImpl();

		private ClassImpl() { set up some stuff };
		...
	}

	The class can then be referenced anywhere as ClassImpl.INSTANCE
---

	The factory method that CodeGen will within the package's Factory class canbe implemented:

---
	public Class1 createClass1() { return Class1Impl.SINGLETON; }
---




Building and invoking

		mvn package

		remember to include the main class nme in the jar manifest

		execute

	java -jar  /Users/kevin/dvl/gitReps/fitStats/target/FitStats-1.0-SNAPSHOT-jar-with-dependencies.jar





Modelling Arrays
		Define a  Data type  e.g. StringArray to mean java.lang.String[]




Ecore Model Properties - Attributes


	Default seems to be Ordered, Unique, Changeable.

*Unsettable
	This causes additional functions to be generated in the implemented class that are geared toward the possiblity that the attribute in question will not have a value. So, as well as the usual getAttribute() and setAttribute(), we get:

			unsetAttribute()

			isSetAttribute()

*Changeable
	When unset, this prevents the function  setAttributAe() from being generated.


*Unique
	Indicates whether the same value can occur for more than one Object within the Class
	Although it does not seem to affect any generated code in the Class itself, it does set the @model attribute Unique=false in the Interface


*Volatile
	When set, no storage will be allocated for the field i.e. <<NO FIELD WILL BE GENERATED>>. Instead, just the get() and set() methods are created. These are completely empty functions for the user to implement as desired.

	This is generally used for fields that are simply derived from other fields in the object.

*Derived
	Similar to volatile in concept, I think, except that a field, getters() and setters() are generated. Could not find any difference in the code so generated, but I suspect it might be present in any generated code that saves the object to Disk etc.   I suspect the field will not be included.

	However it does not seem to effect anything in the code.
	Although it does not seem to affect any generated code in the Class itself, it does set the @model attribute derived=true in the Interface

*Transient
	This does not seem to effect anything in the generated code in any way.
	Although it does not seem to affect any generated code in the Class itself, it does set the @model attribute transient=true in the Interface

*ID
	This only seems to have relevance for objects that sit in Containers (Set, List etc). It determines whether the attribute can be used to uniquely identify the object WITHIN that container.

	Although it does not seem to affect any generated code in the Class itself, it does set the @model attribute Id=true in the Interface

*With each of the above...

	With each of the above, the generated class  XxxxPackageImpl is also impacted, with the Boolean flags set or cleared as appropriate. Don't quite know what that does yet.

---
	FitStatsPackageImpl.java

		initEAttribute(
				getDecoderClient_MainFactory(),
				this.getMainFactory(),
				"mainFactory",
				null,
				0,
				1,
				DecoderClient.class,
				!IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED
			);
---


Refactoring

	It is relatively straightforward to move model components around into different classes, packages etc. just by dragging and dropping in the various editors.

	However, if there is non-generated code in any of the implemented classes, then this will need to be moved into the new implementation classes OUTSIDE of the modeling tools.

	In these circumstances, the File Comparison tool in the Java Perspective is a fantastic help. Learn how to get the most out of it.


Reflective and non-Reflective representtion of Attributes/Refernces in the generated code.

	The generator has the capability to generate code in several different ways. One of these, known as Reflevetive Feature Generation, will generate classes without explicit member attributes and class references. Instead, a model of the class itself is constructed (a meta-model), and the members/references stored within a datastructure within hte class itself.

	Rather than referencing the atributes directly, you are required to access them through the getters and setter function which it generates for that purpose.

	This seems to work reasonably well, although I find the code you need to write generally a but more cumbersome, and less fluent.

	HOWEVER I HAVE ENCOUNTERED SOME SIUTATIONS WHERE CODE GENRATED TO USE REFLECTION DOES NOT WORK PROPERLY AND THROWS ERRORS THAT NON-REFLECTIVE CODE DOES NOT.

	The feature is activeated/deactoveated via the Model --> Feature Delegation property of the GenModel.

	Generally speaking, non-reflecitve code is easier to read, easier to bug and works correctly in more situations. Use it unless you have a good reason not to.







Problems

	Have seen this reasonably frequently

		Exception thrown org.eclipse.emf.common.util.BasicEList$BasicIndexOutOfBounds Exception: index=0, size =0

			Shut down all projects that aren't strictly necessary

			Shutdwon and Reboot Eclipse itself

		This has resolved this in the past.




Perspectives within Eclipse IDE

	A <<perspective>> within IDE is little more than a saved configuration customises what Tools and Actions are available within the Main IDE window. It customises what is shown:

	text menu con.
	* Within the toolbar area

		* Within t
		***via the Aird editorhe Menu Structure


		* What actions are triggered by selecting options from those Menu/Toolbars

		* What shortcuts Are Available.

	When you install a IDE particular IDE plugin/tool, they will often come with their own perpective or set of perspectives.

	The Full list of installed perspectives is available form the Perpectives Toolbar button, or form the Window-->Perspectives option.

	You can install commonly used perpectives to the Toolbar, where they sit to the far right. They canbe customised to your hearts content.






Rebuilding my IDE

	The version of IDE that I had been using for modelling etc had become a bit cluttered. As I'd played around with diffferent technologies etc. so more plugins had been installed each with their own perspecives etc. So it was genrally getting a bit difficult to see the wood for the trees.

	Therefore before proceeding with the Model based work any futher, decided to strip things back a

	Downloaded latest version of Eclipse IDE (2019-12)

	https://www.eclipse.org/downloads/packages

	This comes in various different packagings, each geared towards a slightly different audience.


	( which has the Modelling bits and pieces pre-instlled)

	Insttalled some addition

		* m2e - Maven integraton for Eclipse

		* Papyrus fro UML

		* Vagarnt Tooling

		* GitHub (Git was already installed)


Created a copy of the ~/eclipseWorkspace ~eclipse-workspace.2019-12


*Building a Modelling Environment on top of an existing Maven / Project.

	There may be circumstances where you already have a working development environment that you wish to layer the EMF Modelling and Code Generation Capabilities on top of.

	We assume we have a working Maven project structure outside of the IDE.

**Firstly import the Maven project to the IDE

	File --> Import Projects From Filesystem

	/Users/kevin/dvl/gitReps/fitStats

	This should detect the 'maven' and 'git' natures of the project, and configure the projects source folders


*Create the model folder to hold the principle model files.

**If we are creating an empty model.

	If we have not yet done any modelling anywhere (either in some external modelling tool, like {{{./onPapyrus.html}Papyrus}}), or using something that creates a .core file but in some other project) or do not have any annotated java sources to import, we should start with an empty <<<ecore>>> file. The IDE provides one we can use.

		New --> Other --> <<<ecore>>> Model

	When prompted, elect to base the model on a Package (EPackage). (You can choose a number of different objects to form the base object within your model file. However it is probably not worth modelling at any lower level that that.)

	This will add into our project an <<<ecore>>> File, wrapping a package that is:

		* empty;

		*	unnamed;

		[]

	We need to name the package it wrappers before it is properly useable.

***Name the package.

	Open the created <<<ecore>>> file with the 'Ecore Model Editor' (Not the Sample <<<ecore>>> Model Editor) (why the two?). We need to give the currently anonymous package (now embedded in the <<<ecore>>> file) a name and Namespace e.g

---
	Name --> FitStats

	Namespace URI --> hhtp://www.pegortech.co.uk/FitStats

	Namespace Prefix --> FitStats

---

**Multiple Top Level Packages.

	We are not restricted to a using a single <<<ecore>>> file in our overall modelling project. If we have several top level packages (i.e. packages that are not nested within other classes), then we can create further empty <<<ecore>>> files, as necessary. They are created and added in to our project folder in exactly the same manner as above.

***Viewing Cross File References

	It is perfectly possible for an Element located in one <<<ecore>>> file to make references to Elements located in another. These reference are not always obvious. If you open a an <<<ecore>>> file that references OTHER <<<ecore>>> files with either the 'Ecore Editor' or 'Sample (Simple?) <<<ecore>>> Editor', it will automatically open BOTH Files.

	If you use a lower level editor, such as the XML editor, then you can see the nature of the Element reference. It looks like this:

	ecore:EClass Package1<<<ecore>>>#//NewEClass2

	i.e.

	ecore:EClass <PackageFileNameInProject>#//ElementName


	Note however, if you open a file that contains element that are <<referenced>> by elements in other files (as opposed to referencing), then the referencing file is NOT opened.


***Beware

	Be careful with crossfile references. If you inadvertently delete a model file that is referenced by another then you will corrupt your model.


**Refactoring <<<ecore>>> Files.

	It is possible to move elements to different <<<ecore>>> files using the <<<ecore>>> editor. Just load BOTH files, and then you can drag and drop between. Note that any references to elements that remain in the source file will STIll refer to that element in the original file (i.e. it will now be a remote reference.)


**Creating an <<<ecore>>> file based on other pre-existing <<<ecore>>> file.

	It does not seem to be possible to import the object in one <<<ecore>>> file <<directly>> into another. There are several ways to do this indirectly however:


***Drag and Drop

	First create an empty <<<ecore>>> file as described above. You can use the <<<ecore>>> Editor to open both this empty file and the <<<ecore>>> file you wish to use as source. You can then Cut/Paste or Drag/Drop elements from one file to the other. You can also copy.

	Take care NOT to leave cross-file references; i.e. copy over an element that refers to an element that has NOT been copied over.


***Export/Import

	Although you cannot export directly from an <<<ecore>>> file, you can wrap it up in an .genmodel file as described in the sections below. The <<<EMF Generator>>> tool can be used to access the genModel, and then through it export the <<<ecore>>> data in a number of format (UML, XMI, etc).

	It is then possible to create a new empty genModel file and import from the file exported above. Note that you cannot add to an existing <<<ecore>>> file using this method.




*Adding the Generator Model.

	The <<<ecore>>> file itself holds only data pertaining directly to the structure of the Model. It does not hold anything pertaining to how that model will be implemented. This information is held within the generator model, and at multiple levels, e.g.:

		* the overall model level. This is where most of the information is held.

		* the package level;

		* the Class Level;

		* the Attribute level.

		[]

	Such information would cover such things as:

		* the artefacts that should be generated from the model (Editors, Adapters, Factories, Test Suites etc.)

		* parameters governing how those artefacts are generated.

		* the target infrastructure the model should be generated onto

		* Directory Names, etc

		* the generational style : classes v interfaces; Constructor style;

		[]

	The generator model works by effectively creating a wrapper around one or more <<<ecore>>> models. The generator model seemingly has references to the <<<ecore>>> models it renders embedded within it. So anything that has access to the genmodel also has indirect access to the underlying <<<ecore>>> models too.

	Once the <<<ecore>>> file is wrappered by the .genmodel model, then it becomes endowed with additional functionality, such as:

		* most notably, the ability to generate code; but also

		* export model data in UML or XML formats

		* reload its data from export sources  (Not this will replace the current model rather than add to it.)

		* perform diff type comparisons with previous versions

		* backout recent changes to the model, if so necessary.

		[]



**Creating the Generator Model

	The generator model is created via the <<<EMF Generator Model>>> wizard, as follows:

---
	File --> New --> Other --> Eclipse Modelling Framework --> EMF Generator Model
---

	The model need to be named e.g.:

---
			Name --> fitStats.genmodel (file needs to have .genmodel suffix)
---

	..and an appropriate model imported. The model can be:

		* an existing <<<ecore>>> Model (such as the one created above)

		* from Annotated Java

		* from XML

		* from a UML model

	The tool will allow you to add multiple models (of the same type) if that is what is desired. i.e One <<<genmodel>>> file can wrapper many <<<ecore>>> files.


**Checking out the Generator Model so created.

	We can examine the generated model, with the <<<Genmodel Editor>>>. The <<<Genmodel Editor>>> will show BOTH the <<<genmodel>>> file AND the <<<ecore>>> files that it is tasked with rendering. The generated model will attach additional properties to elements within the <<<ecore>>> file describing how they will be implemented.

	Sets of generator properties can be set at multiple levels:

		* at the overall genModel level.

		* at the individual class level and below.

		[]

	There are a lot of parameters available at all levels, and, for a lot of them their meaning is not immediately obvious. However, the float over help is very helpful in this regard.

	The default values are fine for most purposes, but it is worth checking that the following are set as you want:

---
		genModel Level:

			Model Tab:

				model directory --> /fitStats/src/main/java

				Operation Reflection -->

				Suppress Interfaces -->

				Suppress Notiifcation -->



		Package Level:

				Base Package --> uk.co.pegortech

				Adapter Factory --> true   (i.e. whethet to creates an adapter factory and switch class for the package)

				Generate Model Wizard --> true (i.e.  Hm No sure about this)
---


	<(Need to work how to disable the generateion of th edit/editor/test models etc.)>




*Adding the representations (aird) File.

	Neither the genmodel or the ecore file contains any properties that pertain to how those models may be displayed, edited or otherwise represented to potential user of the model; a developer, a tester, reviewer etc. In order to imbue the model with these properties, a third model wrapper is deployed.

	Different tool providers can potentially wrapper the genmodel/ecore models in different ways, but the 'standard' provider or representational tools is Sirius.

	The Sirius provider wrappers the genmodel/ecore models with a Representations file (.aird) file. A Representations file holds representations: typically, diagrams and tables. (Don't confuse adding a Representation (i.e. a table/diagram) and adding a Representations File (a file that will contain those representations).

	A modelling project, SHOULD have only ONE representations file.

	The aird/representations file can be created in a couple of ways. Either:

		Highlight the <<<ecore>>> file and select the 'Initialise <<<ecore>>> Diagram'

		This will give the opportunity to

			* provide a filename,

			* choose an initial representation to create (a diagram or table)

			* choose the <<<ecore>>> package or other element in the <<<ecore>>> model on which to base that diagram/table.

			[]

	or:

		Add a Representations File via the Sirius wizard available under:

---
	File --> New --> Other --> Sirius --> Representations File
---

		This will give the opportunity to base the file either on an initial existing model, or just create an empty representations file.

	A single representations file can wrapper multiple ecore/genmodel files within a project, and hold multiple representations for each.


*The aird Editor

	The 'Aird Editor' is the best tool for managing the model representations. If you examine an .aird file, you will see that the file SHOULD have sections for both:

		* the	.core model

		* the	.genmodel model

	Additional representations can be added to either of the above models. In practice, it is sensible to add them to the genmodel.

	The properties of the both SHOULD include a Generation tab. IF this is not present, then the 'Generate' option will not be available as a right click from within the Diagraming tool, which is quite an inconvenience. If ind this happens when the representation is based on a an ecore model that has not yet been wrappered by a genmodel model.

**Adding additional representations

	New Diagrams and tables can be added in a couple of ways:

***via the context menu.

	Additional Representations (Diagrams or table) can be added into the EXISTING aird file, by selecting the package from within either the <<<ecore>>> or .genmodel section of the existing file and selecting the <<<New Representation>>> from the Right Click menu.

***via the Aird editor

	Alternatively, open the Existing aird file with the Aird editor and add in the new representations there


A General Warning

	It is best not to be too clever in trying to have multiple cross-referenced ecore models managed by multiple genModels used by multiple Aird documents. It is possible to corrupt the models unless you are careful. Keep it simple stupid.



*Reloading a model from Annnotated Java Classes.

	The EMF Code generator can not only generate Java Code from the contents of an ECore model, but it can also populate an ECore model from properly annotated Java Code.

	It relies on associations existing between the Ecore model and some filesystem locations that is configured into the .genmodel file.

	By right clicking on the genmodel file and selecting Reload

		---> Reload

	it is possible to specify one of a number of source types, of which the most useful are likely to be

		* Annotated Java

		* Ecore Model.


	At the moment, I am not clear what happens to the stuff in the existing model. I would guess, elements that exist are
	updated, and elements that don't exit are created.


	In order to pull stuff in from an entirely unrelated project, one way of doing it is to:

		1. Create a temporary empty modelling project

		2. copy the required source files into that projects source directory

		3. Reload the GenModel as described above.

		4. Open the Ecore model with the ECore Editor ( NOT the Sample Ecore Model Editor)

		5) Using the little Resource loader icon in the top right of the diagram to open the ecore diagram from the project to which you wish to import the classes.

		6) You can then cut and paste classes between ecore files as necessary


	If the files exist in the filespace of the current model, then you can just create a second model file within the
	project.

	 	File ---> New --> Other --> ECore Model

	Then wrapper it in a new genModel File

	 	File ---> New --> Other --> EMF Generator Model

	The required Files can then be loaded to this, and cut and pasted into thoe old model as required.

	The redundant files can tehn be deleted.




Various Notes derived from the experience of programming with the EMF framework


	At the moment, this is just a collection of various notes and jottings made during experimentation with the tools offered by EMF. It will need to be organised into some sort of coherent structure in due course...


*Leverage the refactoring capabilities of Eclipse

	The EMF framework favours modelling in interfaces which are the implemented by classes. If you wish to reverse engineer an existing class, and import it into an ecore model, then it need to be transformed into an Interface and its implementing class.

	The Eclipse IDE provides a convenient tool for extracting an interface from an existing class.

	Once that is done, the resultant interface can be annotated with @model tags as required and genModel used to pull the interfaces into a model file.


*Maven POM changes to support EMF generated methods.

	The classes generated by the EMF framework include a number of its own methods and supporting classes. These make use of particular objects drawn from the org.eclipse.emf<<<ecore>>> package. For maven to control the building of these classes, this dependency needs to be added the pom file.

	The version of the library corresponding to this 12-2019 release was located within Maven Central and the dependency

	<dependency>
		<groupId>org.eclipse.emf</groupId>
	  <artifactId>org.eclipse.emf.ecore</artifactId>
	  <version>2.20.0</version>
	</dependency>

	added into the pom.




*Get it right first Time!

	When you create your modelling project and the modelling files that go with it, it is a good idea to get the names and spelling etc correct. While it is perfectly possible to refactor a model to change these things at a later date ( and I have done so successfully), there are a lot of little changes to make in lots of files. So better to avoid that if you can.


*Creating a Modelling Project v Creating an <<<ecore>>> Modelling Project

	The 'Create a Modelling Project' wizard is provided by Sirius. It is not based on an any underlying data model (e.g. <<<ecore>>>, uml etc), but instead starts with a container for representations to which you can then add Models and then representations (tables/diagrams) based on the at model.  It will create a project with a single, empty Aird (Representations) file. Models/Representations can then be added with the Aird Editor, as desired.

	Creating a <<<ecore>>> Modelling Project is a wizard that goes much further. It creates an <<<ecore>>> model file, genmodel file that wrappers that <<<ecore>>> file, and a Sirius representations file (.aird) file that wrappers the .genmodel file.


*Using the factory methods instead of constructors.

	It is generally considered good practice not to use object constructors directly. Look in 'Effective Java' for all the good reason.

	Instead use the create<Class> factory method. (This does seem to itself call the Constructor). Any logic that you want to put into a Constructor, such as initialising attributes etc can still go in here.

	Note that the genModel tool will only generate a no-parameter Constructor, along with a no parameter factory method. It is obviously possible to customise the object, post-creation, with various setter() methods but this does mean that the  object exists in partially initialised state, at least until these setters etc have been applied.

	If that is not acceptable (and it generally isn't, in my book), then additional factory methods AND Factory methods can be provided. This is just a matter of adding in @model NOT annotated methods with the required signatures. Again, the new factory method should be used in preference to the bare Constructor().

	For even more complicated cases, modelling a Builder helper class may be useful. This would essentially be a nested static member class of the Class in question. See effective Java for details. In this situation, we would effectively be creating our own factory methods, rather than using the the ones generated by the tool.


*Unsetting Properties that had previously been set.

	If you set a default value property for an attribute and then at a later date decide that you don't want that default attribute value, just deleting the value is no good; it persists and appears in the generated code as a value of "". Sometimes this is harmless, but other times it does no any syntactic sense.

	To get rid of the problem you need to get rid of the property that has been set entirely. The easiest way I have found to do this is by using the XML editor DIRECTLY on the <<<ecore>>> file, and finding and deleting the property.

*When Editors are slow to open.

	I suspect that different Editors perform different levels of validation whenever a model/representation in opened. It does appear that certain constructs take quite a lot of time to validate. In particular:

	When using the <<<ecore>>> Model Editor:

		DataTypes/Interfaces will often be associated with external datatypes via their Instance Class Name and Type Class Name attributes (e.g. org.apache.commons.math3.stat.descriptive.DescriptiveStatistics ). When the editor attempts to open it a model with such external class references, the validation is very slow. It can easily take 5 minutes to open such a model (although they do generally get there in the end). If you take those External Classes out, the model opens in a few seconds.

		Opening the same Model with the 'Sample Model Editor' is much quicker: presumably because it isn't doing the same degree of validation.

		Also, some external object seem to be much faster to be validated than others; the java.lang.Objects seem to validated pretty quickly. (Maybe its because these are early in some sort of search path??).

	Validation does seem to be configurable at:

		* project level;

		* workspace Level;

		* installation level.

		[]

	I have tried disabling all this validation  (Properties --> Validation), but it does not seem to make any difference to the speed with which this particular editor opens.

	Also, if it is indeed attempting to validate these external references, it does not seem to be able to do so effectively. If I deliberately put an invalid External Class into one of those fields, it does not pick it up.

	Not also that there are Validate Diagram and Validate options available inside some of the tools too - these do not seem to take the same length of time to do their work.

	This remains a curiosity. Have been unable to find anything on the internet which shines any light.


*Disabling the Generation of the edit/editor/test projects.

	During code generation, the codeGen tool is capable of generating 4 codesets:

	 	* code supporting the model itself;

		* an Edit project

		* an Editor Projects

		* a Test Project.

	For the majority of the time we are only really interested in the model, and he rest is just clutter. By default, all 4 components are generated during codeGen.

	For a long time I struggled to find a way disabling everything but the model generation. Stumbled upon a way to do it almost by accident.

	If you set the OutputDirectory of these component within the GenModel to null, it seems to work. Note: By default this is empty anyway, but seems to default to a particular value. This need to be cleared for it to have an effect.




*You can use the power of the IDE to simplify the more tedious tasks

**Use the IDE to import the operations that need to be implemented to support an interface.



Instance Class Name and Instance Type Name.

	These are two closely related things which are generally used to indicate that at Class/Instance is external to the model. The two terms, I believe, are necessary to properly represent {{{./onJavaLang.html#Generics}Generic Classes}}.

	If the Class is non-generic, the Instance Class Name and Instance Type Name will be the same.

	If the Class is a generic one (as most Collections are), then the Instance Type name will reflect the Parameterised Class Name. For instance, java.util.List\<String\>, java.util.List\<Apple\>, java.util.List\<Pear\>.

	The Instance Class Name will be the <<erased>> name of the generic. i.e. the way the Class will be represented by the compiler. This will usually be the <<raw>> class e.g. java.util.List. However, theoretically, it will the most specialised class capable of representing any of the possible Generic classes. For example, java.util.List\<Fruit\>.



How Providing Instance Names for Modelled Classes and Interfaces affect the artefacts generated.

*Choices in representing Classes/Interfaces in out model

	When modelling an application we will typically want to use objects drawn from three sources:

		* Objects created and contained in the package being modelled;

		* Objects created and contained in other packages within the model;

		* Object created and contained in package external to the project, e.g. standard Java Library packages or those from some other provider.


	The objects modelled, too, will of two major types:

	  * Classes

		* Interfaces


	In order to model these things, the ECore model provides the following facilities:

		* Choices as to how the Objects are modelled within Ecore. These are:

			* As Ecore Classes (Abstract or Concrete)

			* As Ecore Interfaces (always Abstract)

			* As Datatypes

			[]

		* An option to model the Class/Instance as an External Object by providing an Instance Class Name and Instance Type Name;

		* Generator Configuration choices:

			* to transform modelled classes into Instance/ImplementationClass combinations (the default, and 'right' way to go)

			* as direct classes alone.

			[]

		[]


	Each of these choices will be reflected in the way that the codeGenerator chooses to represent the model in terms of the actual, generated Java Classes and Interfaces. Since the generated classes/interfaces will need to be fleshed out into a full working application, it is important to ensure that these base building blocks form the best possible starting point for your application.

	A fundamental concept of the EMF modelling process that the ecore model and the generated classes/interfaces are different representations of the SAME underlying model. It should ALWAYS remain possible to both generate the code from the model AND generate the model from the code.

	If we are to respect this principle, it means we do not have the complete freedom to choose and mould the classes/interfaces that implement that model: we have to retain the generated skeleton, and flesh it out. If we don't we will lose the power to go transform code <---> model and vice versa.

	Therefore, in order to get the best possible starting point for our implementation, it is important to understand how the various choices we make in modelling get reflected in the classes/interfaces that are subsequently generated.


*Issues regarding EMF Functionality included in the generated model.

 	As has been noted elsewhere, the code generated by the EMF framework includes additional functionality 'for free' (Persistence, Notification, Reflective Services, etc.). The price we pay for this is that some supporting infrastructure needs to be built into each of the implementation classes, and some of this infrastructure can be difficult to decipher.

	Objects obtain this infrastructure typically by implementing particular ECore interfaces (and usually the Ecore Interface itself).

			* Where the generator generates Interfaces, the generated interface will specify the <<<Ecore>>> interface is implemented ( Do I mean inherited?);

			* Where the generator generates Classes, the generated Class will extend the <<<MinimalEObjectImpl.Container Class>>> (which implements the EObject Interface).

	Note that these are the Objects used by default. Within genModel, it is possible to configure the use of different base objects/interface,  but this can only operate at the level of the whole Model, not at the level of individual classes.


	 	EObject

		ClassWithNoInstanceName
		ClassExtendingClassWITHinstanceName





*Ecore model representation and their generated code form

	The following paragraphs tries to summarise how different modelling scenarios will be represented in the code generated. I have looked at the situation, firstly, with regard to how standalone classes/interfaces are represented, and then how classes involved in Inheritance relationships are modelled.

**Datatypes

	Datatypes are a simple way for external Classes and Interfaces to be referenced in the model. The fully qualified object name (Class/Interface) is associated with the named Datatype. The datatype name then just acts as a proxy and the actual class name will get 'expanded out' within the generated Classes/Interfaces.

***Principle Restriction

	The biggest shortcoming with using this as a representation of a Class/Interface is that it is very limited in the ways it can be related to other components of the model. Specifically:

		* They can't participate in any relationship (other than containment);

		* They can't participate in Inheritance Relationships;

	In practical terms they can only be used to as attributes with modelled Classes. i.e. effectively as contained Objects within a modelled class.





***Using GenModel with Default Settings (i.e. Interface plus Implementing Class).

****Standalone (un-extended) Classes/Interfaces

	The following describes how standalone, unextended classes/interfaces (i.e. no inheritance relationships) are likely to represented. The

[./images/classInterfaceGeneration.png]

	The table below indicates whether classes, interfaces or both will be generated both for natively modelled classes/interface (no Instance Class/Type name) and for External Classes (ones with a Instance Class/Type name).

	NB. For external objects, the designation Class/Interface reflects how the object is represented in the model. If it is represented as a class in the model, it does not mean that the external object actually IS a class.

*--------------------------------+----------*----------*-----------*-----------*
|                                | Internal | External | Internal  | External  |
|                                | Class    |  Class   | Interface | Interface |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Interfaces           |   X (1)  |     -    |   X (2)   |     -     |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Class Implementation |   X (3)  |   X (4)  |     -     |     -     |
*--------------------------------+----------*----------*-----------*-----------*

	Generated Signatures:

---
	1. public interface ClassWithNoInstanceName extends EObject {}


	2. public interface InterfaceWithNoInstanceName extends EObject {}


	3. public class ClassWithNoInstanceNameImpl extends MinimalEObjectImpl.Container implements ClassWithNoInstanceName {}


	4. public class ClassWithInstanceNameImpl extends MinimalEObjectImpl.Container implements \<TheNamedClass\>

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>
---


****Extended Classes/Interfaces


[./images/inheritance.png]

*****By way of Explanation

	In the tables that follow, an X will indicate that a implementing Class/Interface has been generated. Mostly these will have been generated in such a way that Ecore functionality is drawn in too. Where this DOES NOT happen, this is indicated in the table with an * instead. The number refer to the actual interface/class signature indicated in the block that follows.

*****Extending a Class

*---------------------------------+-----------------*----------------*------------------*----------------*
|                                 | Class Extending |    Extended    | Class Extending  |    Extended    |
|                                 | External Class  | External Class |  Internal Class  | Internal Class |
*---------------------------------+-----------------*----------------*------------------*----------------*
| Generated Interface             |       X (1)     |        -       |       * (2)      |      X(5)      |
*---------------------------------+-----------------*----------------*------------------*----------------*
| Generated Class Implementation |       * (7)     |     X (11)     |       * (8)      |      X (12)    |
*---------------------------------+-----------------*----------------*------------------*----------------*

	Generated Signatures:

---
	1. public interface ClassExtendingClassWITHinstanceName extends EObject, \<TheNamedClass\> {}

		<<NB This is syntactically incorrect - an interface cannot extend a CLASS!>>

	2. public interface ClassExtendingClassWithNoInstanceName extends ClassWithNoInstanceName {}


	5. public interface ClassWithNoInstanceName extends EObject {}


	7. public class ClassExtendingClassWITHinstanceNameImpl extends ClassWithInstanceNameImpl implements ClassExtendingClassWITHinstanceName {}


	8. public class ClassExtendingClassWithNoInstanceNameImpl extends ClassWithNoInstanceNameImpl implements ClassExtendingClassWithNoInstanceName {}


	11. public class ClassWithInstanceNameImpl extends MinimalEObjectImpl.Container implements \<TheNamedClass\> {}

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>


	12. public class ClassWithNoInstanceNameImpl extends MinimalEObjectImpl.Container implements ClassWithNoInstanceName {}
---



*****Extending an Interface

*---------------------------------+--------------------*--------------------*--------------------*--------------------*
|                                 |  Class Extending   |     Extended       |  Class Extending   |     Extended       |
|                                 | External Interface | External Interface | Internal Interface | Internal Interface |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generated Interface             |      X (3)         |        -           |       * (4)        |        X (6)       |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generating Class Implementation |      X (9)         |        -           |       X (10)       |        -           |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*

	Generated Signatures:

---
	3. public interface ClassExtendingInterfaceWITHinstanceName extends EObject, \<TheNamedInterface\> {}


	4. public interface ClassExtendingInterfaceWithNoInstanceName extends InterfaceWithNoInstanceName {}


	6. public interface InterfaceWithNoInstanceNmae extends EObject {}


	9. public class ClassExtendingInterfaceWITHinstanceNameImpl extends MinimalEObjectImpl.Container implements ClassExtendingInterfaceWITHinstanceName {}


	10.	public class ClassExtendingInterfaceWithNoInstanceNameImpl extends MinimalEObjectImpl.Container implements ClassExtendingInterfaceWithNoInstanceName {}
---



****Conclusions

*****Internal Classes

	[[1]] Following code generation, the internal classes will be represented as a Interface (of the same name as the modelled Class) and a Class that implements that interface.

	[[1]] The generated interface extends the EMF System Interface EObject by default.

	[[1]] The generated Class will extend an EMF System Object <<<MinimalEObjectImpl.Container>>>, as a means of implementing the EObject interface. As a consequence, we can not use inheritance as a mechanism to develop the functionality within our implementation objects. This is an undoubted drawback and is discussed further in a further section.


*****Internal Interfaces

	[[1]] The internal Interfaces will be represented as a single Interface extending EObject. It he modelled interface extends some other modelled object, it will extend the interface of that modelled object too.


*****External Classes

	[[1]] If you need to include an external class in the model, the only way to reliably model it is as a <<<Datatype>>>. Even then only Non-generic types can be reliably included. If you attempt to include a generic, it reduces it to its raw form within the implementation class (when really you need it to retain its generic nature intact, and as modelled).

	[[1]] If you attempt to model it as an External Class (i.e. a Class with Instance/Class Names), it will assume it is an External Interface and the generate a class which attempts to implement its 'interface' (which classes don't have, and so is syntactically garbage.)

	[[1]] If you attempt to model it as an external interface, then no Classes/Interfaces for it are created at all, which is what we want. However, should you attempt to EXTEND your modelled class, then class extending it will treat it as an interface and once again generate syntactically incorrect guff.


*****External Interfaces

	[[1]] The only external objects that can be reliably be modelled are Interfaces. Classes cannot (see above) the generate a class which attempts to implement its 'interface' (which classes don't have, and so is syntactically garbage.)

	[[1]] The external interface can be represented on the model as EITHER a Class OR an Interface. The objects generated will be differ:

		* When modelled as an Interface (i.e. the more natural way), the interface will have no direct representations of it generated at all (which is correct). Any Class/or Interface that extends it, will implement the external Interface directly. So if we are modelling the external interface List, ALL classes that extend it will need to implement functionality to implement List.

		* When modelled as a Class, no interface will be generated for it (since the interface already exists externally). However a Class to DIRECTLY IMPLEMENT that Interface WILL be created. ie if we model the List interface, a class ListImpl will be created that implements List. Any classes/interfaces that extend our modelled Interface will extend the DIRECTLY IMPLEMENTING  class AND implement the original, external interface. In contrast to the above, the List functionality would need to be implemented just once in the parent class. The classes that extend it would inherit the List functionality rather than having to implement it themselves.



***Using GenModel With Suppressed Interfaces.


****Standalone Classes/Interfaces

*--------------------------------+----------*----------*-----------*-----------*
|                                | Internal | External | Internal  | External  |
|                                |  Class   |  Class   | Interface | Interface |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Interfaces           |     -    |     -    |   X (1)   |     -     |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Class                |   X (2)  |   X (3)  |     -     |     -     |
*--------------------------------+----------*----------*-----------*-----------*

	Generated Signatures:

---
	1. public interface InterfaceWithNoInstanceNmae extends EObject {}


	2. public class ClassWithNoInstanceName extends MinimalEObjectImpl.Container implements EObject {}


	3. public class ClassWithInstanceName extends MinimalEObjectImpl.Container implements <TheNamedClass> {}

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>
---


*****Extending a Class

*---------------------------------+-----------------*----------------*-----------------*----------------*
|                                 | Class Extending |    Extended    | Class Extending |    Extended    |
|                                 | External Class  | External Class |  Internal Class | Internal Class |
*---------------------------------+-----------------*----------------*-----------------*----------------*
| Generated Interface             |        -        |       -        |       -         |       -        |
*---------------------------------+-----------------*----------------*-----------------*----------------*
| Generating Class Implementation |       X (1)     |      X (5)     |      * (2)      |      X (6)     |
*---------------------------------+-----------------*----------------*-----------------*----------------*


	Generated Signatures:

---
	1. public class ClassExtendingClassWITHinstanceName extends ClassWithInstanceName implements EObject {}


	2. public class ClassExtendingClassWithNoInstanceName extends ClassWithNoInstanceName {}


	5. public class ClassWithInstanceName extends MinimalEObjectImpl.Container implements <theNamedClass> {}

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>


	6. public class ClassWithNoInstanceName extends MinimalEObjectImpl.Container implements EObject {}
---



*****Extending an Interface

*---------------------------------+--------------------*--------------------*--------------------*--------------------*
|                                 |  Class Extending   |      Extended      |  Class Extending   |      Extended      |
|                                 | External Interface | External Interface | Internal Interface | Internal Interface |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generated Interface             |          -         |          -         |          -         |        X (7)       |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generating Class Implementation |         X (3)      |          -         |        X (4)       |         -          |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*

	Generated Signatures:

---
	3. public class ClassExtendingInterfaceWITHinstanceName extends MinimalEObjectImpl.Container implements EObject, \<theNamedInterface\> {}


	4.	public class ClassExtendingInterfaceWithNoInstanceName extends MinimalEObjectImpl.Container implements InterfaceWithNoInstanceName {}


	7. public interface InterfaceWithNoInstanceNmae extends EObject {}
---

****Conclusions

*****General

	As you might expect, the objects generated when genmodel is operating in 'Suppressed Interface' mode are much more intuitive, though not completely so. In general, things modelled as interfaces get implemented as interfaces and things modelled as classes get implemented as classes.


*****Internal Classes

	As expected, these get implemented as a Class. Any Class the extends it also gets implemented as a class extending that class. The generated classes will Extend the EMF System object <<<MinimalEObjectImpl.Container>>>. So once again, wee can not use inheritance as a means of fleshing out the functionality in the implementation classes.


*****Internal Interfaces

	Again these behave pretty much as expected: a modelled interface will get implemented as a java interface, and once again, by default, these will implement the EMF system interface EObject.


*****External Classes

	Once again, it is NOT POSSIBLE to model external classes in such a way that hey will get sensibly reflected in the java code representation. Once again, the tooling behaves as if it is External Interfaces that are being modelled. As before, the only way to represent true Classes is to model them as Datatypes; and that restrict the extent o the modelling that can be performed.


*****External Interfaces

	[[1]] Things that get modelled as external interface will NOT be directly represented in the generated code at all, which is as it should be. Object that inherit from the external interface

	[[1]] However, as before, external objects that at REALLY interfaces but modelled as External Classes, will get modelled in the representation, but will be modelled as Interfaces.  The class will be named according to how it is named on the model and be a DIRECT Implementation of whatever external interface it references.



Why having our implementaion inherit from the MinimalEObjectImpl.Container is potentially problematic.

*The Problem

	As has been described elsewhere in this document, Classes generated by the EMF framework will automatically extend an EMF system object in order to imbue that class with System behaviours. Because Java only allows direct inheritance from a single class, we can not now use the same mechanism to imbue our classes with functionality that we might wish for the object.

	For example, we might want our Class to be a Collection class and say implement the List interface. In normal circumstances, there are a number of ways that we could do this:

		* Have our class directly inherit from one of the java.util.List implementations, such as LinkedList. However, this route is now closed to us as the class is already inheriting from <<MinimalEObjectImpl.Container>>

		* Use a <<Composition>> design (See Effective Java). Here, a LinkedList would be included as a private member of our implementation class. Because our implementation class has to implement List, NOT our component, we still have to implement all the necessary methods in the implementation class. This is essentially a clerical job, which where we write each reuired interface method in terms of a call to the respective method in the LinkedList member. These are known as forwarding methods.   If the interface is relativley small, then this is not too onerous a task, but it is much more tedious if a large interface has to be implemented.

		In these circumstances, the usual technique to use a Forwarding Class. The Forwarding Class provides Forwarding methods for all of the methods in a particular interface. The Wrapper class (as it is known) can then just sub-class the forwarding class, so inheriting all the forwarding methods it needs.

		However, once again this part of the deign pattern is closed to us, becuase we cannot perform the sub-classing. (Although we can still write the forwarding methods direclty)

		* A similar technique would utilize a private nonstatic member class rather than a privcat member on which to 'hang' the class providing the functionality that implements the List (See Effective Java - Template method/simoultaneous multiple inheritance).The advantage of this is that the member class CAN extend some base class and SO is amenable to more customisation than would be possible if we had just hung it off a private member.  Typically we would use this in conjuction with an Skeleton Abstract Classs ( e.g. AbstractList) and the overide any methods we need to when we extend it.

		However, once again we would need to 'forward' calls from our top level class to our nested class, and again we cannot extend a convenient forwarding class to provide this functionality. We would need to write the forwarding methods ourself.

	These last two are established patterns for implementing inheritance-like behaviour vai a form of compositing, so it is a pity that it can't be implemented directly.


*Possible Solutions

**Model a forwarding Interface interface and have your classes extend that instead of the underlying interface.

	Consider a class that we wish to model, FruitBasket which we want to be a container for Fruit. We want it to implement the List interface, so we can step through the Fruit it contains just as if it <<wre>> a list. We may wish to pass it to another class which promises to process lists. In other words we want it to behave like a List type.

	Being able to endow 'Typeness' like this on any class we choose is quite a powerful tool, so being able to do this via modelling would be advantageous.

	Note that it is trivial to make a component of our Class behave like a List: we just need to include a List as a memebr attribute. Sometimes that way be sufficient. However here we are making the Class as a whole a List-type.


  Take the interface java.util.List as an example. If we model our own Class which implements the List interface directly, as below

			FruitBasket ---> List

	then our class MUST itself implement all the methods in the List interface.


			FruitBasket ---> MinimalEObjectImpl.Container   (extend)
						|
						---------> List														(implement)

	A standard way of Getting around this would be to use a Forwarding Class (as described above) and inherit from it DIRECTLY.

			FruitBasket ---> com.google.common.collect.ForwardingList ---> List (extend)

	Unfortunately, because ForwardingList is an external CLASS and not an interface, the modelling tool finds it impossible to use. It needs to be free to extend Fruit basket to its own > MinimalEObjectImpl.Container  class, and it can't do this if FruitBasket is extending com.google.common.collect.ForwardingList.

	Ideally we would want to ForwardingList to extend MinimalEObjectImpl.Container  instead.



			FruitBasket ---> com.google.common.collect.ForwardingList --> MinimalEObjectImpl.Container   (extend)
																																|
																																---> List (implement)

	However, ForwardingList is not under our control, so we are not free to amend it. We can however, make our own replacement.

	FruitBasket ---> my.ForwardingList --> MinimalEObjectImpl.Container   (extend)
																														|
																														---> List (implement)

	It is much more advantageous to do it this way, rather than let Fruitbasket perform the forwarding itself, because we can re-use the ForwardingList then inconfunctyion with ANY class in out model

	FruitBasket ---> my.ForwardingList --> MinimalEObjectImpl.Container   (extend)
							|																							|
							|																							---> List (implement)
	ToolBox---->|
							|
	BookCase--->|





*Inheritance of the MinimalEObjectImpl.Container container.

	As far as I can work out, all Classes/Interfaces generated by the EMF Framework will be automatically instrumented with the appropriate functionality for them to work within that framework.

		* all the interfaces will either:

			* directly extend the EObject Interface

			* indirect extend the EObject Interface,  by extending another Interface that itself extends EObject.

			[]

		* all the classes will either:

			* directly extend the MinimalEObjectImpl.Container

			* indirectly extend the MinimalEObjectImpl.Container Class,  by extending a class that itself extends MinimalEObjectImpl.Container.

	Note: MinimalEObjectImpl.Container is the default object that will be extended. There are other Classes available within the Ecore Library that also extend the EObject Object, so could conceivably be used in its stead.

	{{{https://download.eclipse.org/modeling/emf/emf/javadoc/2.5.0/org/eclipse/emf/ecore/package-summary.html}org.eclipse.emf.core}}


	Because inheritance works in one direction (children inherit from parents, but parents can't inherit from children), all the code generator needs to do is identify the all the leaf nodes (i.e those classes/interfaces that don't inherit from any other), and use <<THOSE>> to directly extend EObject/MinimalEObjectImpl.Container.

	All other nodes on the model are then guaranteed to inherit the ECore functionality, directly or indirectly, from every leaf node to which it has a route. The generator will choose ONE route to a leaf node and implement it is series of direct 'extends' through the intermediate Class Node. The other inheritance paths will be represented as additional interfaces that are to implemented.

	This is no different from the way the generator resolves {{#Multiple Inheritance}} situations, in general.


*Customising the Root (Leaf) Classes that get inherited.

	If necessary you can add your OWN classes/interfaces for Leaf nodes to inherit from. These can only be specified within the  genmodel model / package level. The generation will assume that the packages that you stick in here THEMSELVES extend/inherit from the Ecore bases classes/interfaces EObject,  MinimalEObjectImpl.Container.



Multiple Inheritance

	In the model, it is perfectly feasible for a class to inherit from MULTIPLE parent classes.

	However, since java does NOT allow multiple inheritance, when the code is generated, the Child class will only directly inherit from ONE of its parents. The other parents it will implement as Interfaces.

	It is the FIRST parent that will be chosen as the class to extend; the others will be represented as interfaces that the child has to implement. Remember, that functionality that is inherited by extension DOESN't Have to be implemented in the child.


	So you can change the parent that is implemented by moving the sub-type relationship to the top of the list within the Core Sample Editor.





		What we want is out own Forwarding Class that inherits from Ecore, that we can then inherit from

				MinimalEObjectImpl.Container --> ForwardingClass -->ClientClass.








Modelling a Forwarding Class Notes.

CAREFUL THIS ISNT WORKING AS EXPECTED.

	[[1]] We are writing a ForwardingClass which will implement a External Interface, say List. (We shall ignore the generic nature for now).

	[[1]] External Interfaces (i.e Abstrat interrfaces with an Instance/Class Name), do not get represented in the implementation as a class/interface; they just get extended/implemented by objects that reference them.

	[[1]] However, any operations/attributes in the External Interfaces DO get carried through as STUB operations in whatever classes that choose to use the External Interface.

	[[1]] So, we want to quicky an accurately get all the operations from the Interface into our Representation of it. One way to do this is to leverage the capabilitis of the java IDE.

	[[1]] So generate a quick dummy class implementing the interface in question. Add a single dummy operation (you will use this later) and generate teh code from. If you examine the class implementation in the IDE, it will warn you that it doesn't implement all the methods in the interface and offer to create STUBS for you. Accept the kind offer.

	[[1]] From the dummy implementation we can now use the IDE's refactor capability to pull an Interface out from this dummy implementation. Save the file as something temporary.

	[[1]] Delete the original External List that you created earlier and re-create as a Local List. Generate the files once more. This will create a List Interface file.

	[[1]] Cut and Paste all the operations from the temporary file you created above.

	[[1]] We are now intending to use this file to as a source for our model. To do so the methods in the intterface file will need to be annotated. The dummy operation that you created earlier will have the necessary annotations so just copy them from that.

	[[1]] Save your Files. Then Reload the Ecore model from the Annotated Java.

	[[1]] The list interface should now be generated with all the operations present in it. Note that he data types will have been converted into Ecore Model ddata types, and a few more DataTypes may have been added to support the types held in the List.


	Aargh!   Needs more work! The Model that is captured Java --> Ecore does not quite translate back Ecore --> Java in a way that fully compiles. More work needed.


*Eclipse Editors

	The eclipse editor provides forwarding method support.

	This is really useful, however it doesn't always generate all the methods that need to be generated...
	Some methods it just seems to ignore... don't know why.

	Actually, I think it only generates functions that CAN delegate. If you are not getting the full list of functions that you are expecting then look check that you have defined member you are delegating too correctly. Pay particular attention if there Are GEWNERICS involved.




Making Model Components Read Only.

	At the level of the File (Resource, in Eclipse Parlance) Eclipse has the ability to restrict the ability to change that Resource. (These settings can be viewed under <<<Properties>>>.)

	There are 2 mechanisms:

	 	* File Permissions;

		* By Marking resource Locked.

		[]

	These are explained more fully below.


*Permission.

	These just manipulate the underlying Unix File Permissions on the file. Making a file read-only removes write permission on the Unix file, a change which will be picked up and managed by GIT (if under Git control).

	Because it is low level, you can pretty much guarantee that the file WILL be truly read only.

*Resource 'Locked' Attribute.

	You can assign a resource as 'Locked'.  For the Mac at least, locking a file will set a special extension attribute on the file itself that prevents it from bing changed even via the file permmisions. This setting too will be captured within git (er, I think)

	It basically will stop a Resource being changed through the Eclipse Workbench and the tools plugged into it.

	However, that is not to say that <<ALL>> tools that are plugged into the Workbench will necessarily <<handle>> the fact that a resource is Locked particularly well. For instance, the following tools have at least some difficulty:


**The Syrius editor

	Manages Readonly/Locked files really badly. The Tool allows you to edit diagrams, Classes etc without restriction AND allows you to save them. If you re-open the diagrams, the changes are <<apparantly>> retained! However if you close the project and re-open it the changes do <<NOT>> persist. This is <<really poor>>

	(Presumably, the Editor is working off cached data for a lat of the time.)

**The Ecore editors

	Doesn't seem to mange the situation brilliantly: it is possible to change properties within the editor, but any saves you make don't stick. They don't get saved to the underlying file. <<HOWEVER>>, it doesn't really give you any warnings that it is not managing to save things, which is a but rubbish.


**The Sample Ecore Editor

	The Sample Ecore Editor seems to manage the situation pretty well : all options allowing changes are effectively greyed out.






Sharing Project Objects

*Introduction

	In your modelling, periodically you will wish to reference objects that are EXTERNAL to your current project. If these are true library objects, then this is relatively straightforward, and has been discussed previously. However, the situation where you wish to include interfaces/classes that you have modelled yourself in another project may need to be handled differently.

	In these situations, we would wish to be able to model with the objects as if they were local to the project (i.e. participate in Relationships, be extended etc.).

	There are several ways to do it. None of these methods, however, is without its problems. Briefly, we can:

		* Represent the external object as a DataType on the diagram. This only works in a fairly limited way; such items cannot be represented within ANY relationships, but will work as Contained classes/interfaces when expressed as attributes of their container class;

		* Represent the external object as an External Interface (i.e. one with the fully qualified classname/instance name provided). This works quite well in many situations; in the generated code, no interface/implementation class is produced (which is what we want; we want the the actual external classes to be found at runtime along the class path, not built within the project).  The drawback from this method is that the code generator is unaware that external classes we are referencing are <<THEMSELVES>> generated, and will <<ALREADY>> be implementing the interfaces required by the EMF framework. Consequently, any classes that extend our external classes won't work; they will unnecessarily extend the various EMF objects in preference to extending our External class. This means we have to manually implement the behaviour we were trying to inherit.

		* We can reference the external object DIRECTLY within the remote eclipse project. However this is only possible if the remote project is <<open>> at the time. However, as described elsewhere, there can be some quite unpleasant side effects if we then try to access that remote object is the project is <<NOT OPEN>>; it can lead to corruption and data loss.

		* We can reference the external Object INDIRECTLY. This is the method that is described below. Although it is relatively complicated, it probably offers the fullest range of modelling features.

		[]


*Sharing By Copying

**Description

	This is a means of pulling a <<copy>> of an Ecore model somewhere else in the workspace and then working with it alongside the primary model of the project. The project will therefore contain two or more .ecore model files: the \<primary\>.core and a \<copy\>.ecore file.

	There will be a <<SINGLE>> .genmodel file that wrappers both files, and will control generation of java objects from both models as if they were contained within a single .ecore file. Since each .ecore file wrappers a different package, the code will be generated into different Java Packages. However, all objects are generated under the same genModel, and are thus controlled by the same gen-model parameters:

		* They will share the same base class (e.g. uk.co.pegortech.baseClass);

		* They will share the same source/destination direcories with regard to source code (e.g. /projectName/src-gen);

		* Generation parameters governing, for example,  Model/Implementation Splits;

		* Files from <<both>> models will be generated from a <<single>> invocation of the genmodel tool.

		[]

	We can create diagrammatic Representations based on either of the 2 models ( \<primary\>.ecore, \<copy\>/.ecore). Regardless of the choice, objects from both .ecore files can be presented on the diagrams. If a representation is based on on one .ecore model, objects from the other .ecore models will be decorated with a tag indicating that they are remote.

	<<NOTE: No relationship is maintained between the original imported .ecore file and its copy; they are free to diverge without restriction. If you do not want this to happen, you must put additional steps in place to ensure that cannot happen. For example, you can make the files Read-Only as described above)>>

	If the intention is to modify the objects contained in the package in some way, care must be taken to ensure that they do not subsequently get confused with the original objects, particularly during jar packaging and distribution. The easiest way to ensure that does not happen is to change the <<BasePackage>> of the package. (If the genModel has a reasonable configuration, the base package is likely to be different anyway.)

	Another possibility is to change the actual package name. This would tend to disguise the origins of the original package. This may or may not be useful, depending on how significantly the copied is to be changed from the original.

**Creating a copied .ecore file setup.

	The following describes the general process of wrappering 2 or more .ecore files within the same

	[[1]] Create a new empty local .ecore file (as described earlier) and amend it to give it a name, namespace etc. If you already have an ecore file containing objects that you have already modelled, then you can skip this step.

	[[1]]	Create a .genmodel file to wrapper it. At the point where the wrappered data sources are chosen, load both the local .ecore AND the .ecore you wish to copy. If you already have a genModel file that you wish to keep, then the genmodel file can be <<reloaded>> instaed.

	[[1]] On the Package Selection specify <<BOTH>> packages as Root packages. Do not select Any referenced Data models.

	[[1]] On completion, any remote .ecore files will be copied to the local project.

	[[1]] The local copy .ecore and the original .ecore file are now fully free to diverge.


*Sharing By Referencing Remote Ecore Files

**Description

	With this means of sharing, no duplicate Ecore files are created. Each Ecore file will be referenced in its parent  eclipse project, and can ONLY be referenced if that project is open. <<This has an immediate important consequence; if the parent project is not open then the data items within its .ecore file can not be referenced either. Some of the tools don't handle this situation particularly well. In particular, the Sirius graphical editor will not show any remote objects if the remote objects is not available, but it will not give any indication that it is doing so: the items will just silently disappear from the representation. If the representation file is edited in any way, then the loss is permanent (although the underlying data model does seem to remain intact.)>>

	It can be a little tricky to set up code generation across Ecore files that are you want to share by referencing, particularly if one of the Ecore files already contains references to remote objects. It does help, however, if you think carefully about how the data is structured within the Ecore files that you are attempting to share.

	An .ecore file is normally based on a single Package, and it will store data about objects contained within that Package. Should one of its objects reference an object in a different package, then a reference to the Ecore model file that contains that remote package will also be held.

	When you attempt to wrapper a SINGLE Ecore file within a new genmodel file, it will realise that there are 2 or more more packages involved in code generation, and provides you with two different options:

		[[a]] the codegen model can manage code generation across BOTH packages. Whatever parameters that are configured for the genmodel will be applied to both packages, and code for both packages will be generated WITHIN THE LOCAL Project. This now means you have two copies of the generated code, one of which does not contain any the custom coding which that was in the original. <<This is almost certainly NOT what you want.>>

		[[a]] The local codegen can be configured to manage the local package, but reference the remote generator model that manages that remote package. In those circumstances, invoking codegen will only ever build the <<local>> package. It will not build the remote package, either locally or remotely. (However see below, re representations.)


**Invoking genmodel from within model Representations where remote ecore models are involved.

	When a new Sirius representation file is created (e.g. an Entity mode), it can be associated either with the local genModel file or the local Ecore model file. Normally, associating the Ecore file with the genModel would be the recommended choice, because that enables code generation functionality from within the diagramming tool. However, in these circumstances it may be better to base it on the Ecore file and so disable code generation. The reason for that is as follows.

	When we create a new Representation, it will ask us to base it on ONE of the packages, either the local or remote package. Regardless as to which we choose, the model can still represent object from both packages: it is just that some object will be represented as <local> and others as <remote>. (Which way round depends on which package we chose to base out representation on).

	However, if generate functionality is enabled from within the graphical tool, it will initiate generation on the particular model upon which it has been based. That means it <<can>> kick off generation in the non-local package, if the representation has been based on the non-local package.

	<<What is more, the java files from the Representation based on a remote file will generated in the remote repository.>>

	This will almost certainly be undesirable. If we are using the remote packages as a remote library, we are probably <<not>> intending to make changes to it. And since it is likely to be a resource shared amongst possibly many projects, accidentally changing it might have unintended consequence for all projects that share it!.

**Accidentally corrupting linked model files

	When you open a single Ecore file with some of the Ecore editors, you may see details from 2 (or more) Ecore files. However, if one of the Ecore files is remotely referenced, the project holding that Ecore file MUST be open.

	If it is not, then various problems will be indicated BUT it is not immediately clear from the messaging what the problem is.

***Sample Ecore Editor

	The Sample Ecore editor doesn't seem to cope with the situation at all well, and throws up lots of Java type Errors. However, because it basically crashes out, it does at least deny you the opportunity introduce any real corruption via  attempted 'fixes' of a problem which does not really exist. Once the remote project is opened, the problem does seem to go away.

***Ecore Editor

	The Ecore Editor on the other hand does not crash. It realises that it can't resolve some of its links, and gives you a 'helpful' drop down boxes for you to fix the problem by choosing something which is 'valid'. <<Should you take that opportunity, either deliberately or accidentally, then you will have introduced corruption into your model.>>

***The Sirius Graphical Editor

	The Sirius editor does not handle remote data at all well. If the parent project is not open, then the data items within its referenced .ecore file won't be reachable either. The Sirius graphical editor will <<not>> show any remote objects if the remote objects are not available. However, it will not give any indication that it is failing to do so; the items will just silently disappear from the representation.

	If the representation file is edited/saved in any way, then the loss of those objects from the diagram is permanent.i The items will need to be re-added back to the diagram, but this is dependent on the user actually noticing that some of the objects have gone missing, which is unlikely.

	Fortunately, though, the underlying data model does seem to remain intact.


**Creating a referenced .ecore file setup.

	The following describes the general process of setting up a genModel file that can reference a remote .ecore file:

		[[1]] Create a new empty local .ecore file (as described earlier) and amend it to give it a name, namespace etc.

		[[1]]	Create a .genmodel file to wrapper it. At the point where the wrappered data sources are chosen, load both the local .ecore AND the .ecore you wish to copy.

		[[1]] On the Package Selection page, specify the local packages as a Root packages only. Elect to add a referenced Data models for the remote ecore dataset, choosing the .genmodel file that manages it in the remote system.

	The referenced Ecore file is now shared between 2 systems any changes made by either system will affect BOTH.


*A Combined Approach to Sharing - the best of both worlds.

	Ideally, we would prefer to guarantee that all of our model will always be available, and so avoid the possibility of corruption which might be introduced when we open a project when objects referenced from a remote closed project are not available. This implies working with a local copy of remote ecore file is preferred.

	Ideally, we would prefer NOT to generate objects from the copy ecore files. Instead we wish to reference their objects from library jars on our classpath at runtime, rather than compiling local copies into out build. This implies that we want local and remote to be under the control of different genmodel files.

	We can achieve this by creating a local copy of the remote Ecore file we wish to reference, but then wrappering it in a different genmodel to the rest of the model. We can then:

	 	* adjust the properties on the genModel file to ensure that files from the copied model are never generated, or;

		* generated under a different class base name or class name than the original classes;

		* written to a different source code directory to the rest of the application so that, even if they do get generated, they wonlt get built into the applicaion itself.

		* File permissions on the remote Ecore and genmodel files can be set to ensure that these are not inadvertently changed.

		[]

	For projects set up this way, it should be possible to:

	 	* safely include objects from BOTH ecore files on any modelling diagram;

		* embed and extend referenced classes as we would if they were local, and have the generated code that references correctly embed the EMF functionality in the right classes and interfaces.

		[]

**Example Project

	A couple of Eclipse projects exist to demonstrate how this arrangement will work:

		* forwardingCollection

		* forwardingCollectionClient.

============


Manually Splitting a Project into Model and Implemention Parts


	Can do this several ways:

		One Project:

			One Package/Ecore file covering model and implementation

				Here I guess we would create seperate diagrams for the Model and Implemention Parts????

				There can only be one genmodel, and it would therefore generate all objects in both model and implemention, each time it ran.


			Two or more Ecore Files representing Tow or more packages, but BOTH controlled by the same GenModel File.

				Here we generate 2 different packages.

					Each package will be generated each time genmodel is run

					They package direcories will sit under the same overall src directory.


			Two or more Ecore Files each with their own genModel File. In theory, each package will control their own package.

				The two packages can now be generated independently, with differeent paramters (NB it is importatnt to specify 'Suppress Interfaces' for both Ecore Models.)

				Once the genmodel file are in place, we can build representations on each mopdel seperately, and we can configure builds of each part of the model seperately too.





		Two Projects : one for Model, One for implemention.





		Differnt Packages for the Model and Implementation.




	The idea of this is to see whether there are any advantages in turning OFF the Interface/Class generation behaviour and doing the modelling explicitly in Classes and Interfaces.

	If you create a model entirely of explicity specified interfaces:

		* These will get implemented Entirely as Interfaces.

		* The 'Leaf' Interfaces will implement EObject

		* Non-Leaf Nodes will implement the interfaces of all other parents.

		* javaDoc will be generatef for all features.


	If you generate a model entirely as Classes:

		* These will get imlemented Entirely as Classes

		* The Leaf Classes will extend MinimalEObjectImpl.Container

		* Non-Leaf CLasses will extend their parent Class and implement their modelled Interface

		* javadoc will be generated for all featrues.

		* Any interfaces will still get modelled as interfaces.


	The advantages I can see are:

		* Ability to document classes more fully from the model : if classes and interfaces are generated together, then the interfaces get reasonably well documented, but not the classes.

		* Ability to choose your own class names etc.

		* Allows you to model implementation detail etc in the classes (rather than just modelling things at the interface level.)










You Can't Turn OFF default Generation Functionality.

	I have tried to play with various genmodel options in order to to try and stop the framework from generating ANY if the EMF artifacts, and just generating exactly what has been modelled.

	THIS DOES NOT SEEM TO BE POSSIBLE

	The models will <<always>> import extend emf objects and generate artefacts that take advantage of them.


Inner Classes

	You cannot represent nested classes/inner classes in Ecore.  The closest the you can get is to model the nested inner class as a Data-type.  This only really works if there is containment reference to that inner class (i.e. it is represented as a attribute in your top lavel class); often that will be the case. If your inner class is just instantiated in a class method, then you can't model it at all.


Runtime platforms

	genmodel has specific support for generating code targeted at the following execution environments:


		* RAP - Rich Ajax Platform;

		* GWT - Google Web Toolkit;

		* IDE - Eclipse IDE;

		* RCP - Rich Client Platform - e.g. Spring;

		[]


Synchronising Maven and Eclipse.

	Maven and eclipse each have their own mechanism for resolving dependencies within the projects that they are controlling. If you are relying on Maven to do your building, then, if the search paths are not properly synchronised, have the situation where something compiles and builds fine under maven, but the source you are editing within Eclipse is littered with Red Error indications.

	This is annoying and reduces the effectiveness of the tool.

	The easiest way to sort the majority of these problems is to use the maven eclipse plugin, as follows:

	This will update your eclipse Build Path and add in the eclipse libraries referenced in the POM to the 'Libraries Section' of the Build path. (These also are visible under the References Libraries tree and the Project Explorer).

	These seem to 'disappear' are regular intervals, but can be repaired once more my running the mvn eclipse:eclipse plugin.

---
	mvn eclipse:eclipse
---

Enabling Git functionality.

	The way I have been using is to:

	[[1]] use git to init a repository as described in {{{./onGit.htlm}Git Notes.}}

	[[1]] With Eclipse ,  From the Context Menu ( Right Click) select the  Team --> Share Project option.







Problems, Bugs and Gotchas modeling and Generating Code.


* java.lang.IllegalArgumentException

	I encountered this problem immediately when trying to run an almost completely generated jar.

---
	java -jar  /Users/kevin/dvl/gitReps/fitStats/target/FitStats-1.0-SNAPSHOT-jar-with-dependencies.jar

	Exception in thread "main" java.lang.ExceptionInInitializerError
	Caused by: java.lang.IllegalArgumentException: The value '' is invalid.
		at org.eclipse.emf.ecore.impl.EFactoryImpl.createFromString(EFactoryImpl.java:470)
		at uk.co.pegortech.FitStats.impl.FitStatsFactoryImpl.createMainFactoryFromString(FitStatsFactoryImpl.java:139)
		at uk.co.pegortech.FitStats.impl.FitStatsFactoryImpl.createFromString(FitStatsFactoryImpl.java:82)
		at uk.co.pegortech.FitStats.impl.DecoderClientImpl.<clinit>(DecoderClientImpl.java:98)
---

	The line causing the failure was:

---
  protected static final MainFactory MAIN_FACTORY_EDEFAULT = (MainFactory)FitStatsFactory.eINSTANCE.createFromString(FitStatsPackage.eINSTANCE.getMainFactory(), "");
---
	and seems to be because the final argument is "".

	The code is trying to set the default initial for an attribute within the class. According to the ecore model, this attribute DOES NOT have a default value.

	However, the code generated for other attributes which also don't have a default value, looks very different, i.e.

---
	protected static final FtpFactory FTP_FACTORY_EDEFAULT = null;

	protected FtpFactory ftpFactory = FTP_FACTORY_EDEFAULT;
---

	as opposed to:

---
  protected static final MainFactory MAIN_FACTORY_EDEFAULT = (MainFactory)FitStatsFactory.eINSTANCE.createFromString(FitStatsPackage.eINSTANCE.getMainFactory(), "");

	protected MainFactory mainFactory = MAIN_FACTORY_EDEFAULT;
---

	When we similarly define the default method code for our problem attribute, the problem goes away.

---
	protected static final MainFactory MAIN_FACTORY_EDEFAULT = null;
---

	Examination of the datamodel with the custom editors ( ECore Editor, Sample Ecore Model Editor), or the .genmodel file with the genmodel editor did not reveal any real differences in the way mainFactory and ftpFactory were modelled.

	However when the xml was examined directly with the xml editor, key differences were apparent:

---
	<eStructuralFeatures xsi:type="ecore:EAttribute" name="mainFactory" eType="#//MainFactory"
	    defaultValueLiteral=""/>
	<eStructuralFeatures xsi:type="ecore:EAttribute" name="ftpFactory" eType="#//FtpFactory"/>
	<eStructuralFeatures xsi:type="ecore:EAttribute" name="segmentScannerFactory"
	    eType="#//SegmentScannerFactory"/>
---

	It seems mainFactory somehow has a default value of an empty string "" and this is NOT the same as null, even though the editors seemingly show these values identically.

	When using the editors it is not intuitively obvious how to set a value back to NULL rather then the empty string. The only way I have found that works is to:

---
			Right Click ---> Restore Default Value.
---

	Also in these circumstances, the XML editor is your friend.




*Another Common Error

	org.eclipse.emf.common.util.BasicEList$BasicIndexOutOfBoundsException: index=7, size=7
		at org.eclipse.emf.common.util.BasicEList.get(BasicEList.java:346)


		Seems to happen sometimes when you delete elements from a model that you no longer want...


		Sometimes this can be fixed just by shutting down and restarting Eclipse...


*<ClassName>PackageImpl Generation
Generating Java class <ClassName>.impl.<ClassName>PackageImpl failed with unhandled exeception
	java.lang.reflect.InvocationTargetException
		java.lang.NullPointerException

	Often this can result simply because the model is,as yet, insufficiently fleshed out to support generation. Maybe some of the attributes/paramters have not been typed?

	Use the 'Validate Diagram'   and Validate options to Highlight where problems might be and resolve them.


*Random Compilation Failure

	IF you are using maven for compiling and packaging, it will attempt to compile all java in the source diirecories. If you have deleted redundant classes/interface from teh model, this DOES NOT mean their source files will be deleted from the source directories. So maven will still be compiling them...and eventually they will become inconsistent with the rest of the model and start throwing errors.

	Make sure to manually remove redundnat source code from the source direcories.








Modelling Exception

	Have not forund a great way to do this.

		Basically donlt model them : add them directly as classes into into the package and donlt use the tool at all.

		Then add tehm onto the model as DataTypes.
