Generating JUnit Test Classes.

	The CodeGen tool has the ability to generated unit test cases.

	By default, a modelling project does NOT enable test case generation.

	It is enable by adding a valid directory to the Tests Properties page using one of the GenModel Editors

	I find this easier to do with the EMF Generator

	If a path is set to NULL, then generation will be disabled.

	Likewise if Edit/Editor dir paths are deleted, generation of that code will be suppressed.


	The default directory will be /\<projectName\>.tests/src

	This is specified relative to the current workspace, so the above will create a new project

	Alternatively, it can al so set to within a directory within the current project


		/\<projectName\>/src/test/java

	This is where typical maven archetypes will where typical maven archetypes would look for them, so this seems like a sensible place.)


JUnit Test Classes generated.

	Even the more recent versions of codegen generates test classes based on JUnit 3 syntax. This is pretty old; version 5 is now the norm. I can find no way of changing this in configuration, and I can find no references to new versions on the web.

	However, as described below, this is not necessarily a problem.

Types of test cases generated.

	The format of the test cases generated will vary, depending on HOW the classes and interfaces have been modelled/generated.

	Where EMF is configured to represent class entities as a interface plus Implementing class (the default):

		A concretes test class will be generated for each class entity modelled, e.g.

---
		public class DecoderClientTest extends TestCase {...}
---

		An abstract test case will be generated for each identity modelled directly as an interface e.g.

---
		public abstract class FileServicesTest extends TestCase {...}
---

	Where EMF is configured to represent class entities directly as Classes, concrete test classes only will be generated.

	As you might expect, the Abstract Test Classes are not directly runnaable; they need to be extended by concrete test case before that is possible. This is described more fully later.



	In addition to test cases for each modelled class, the tool will also generate test suite classes to facillitate the easy running of all the tests in a package. Twoi are generated

		\<packageTest\>

		\<packageAllTests\>

	( There is also an example Test Case that can be generated: but this can be turned off with the genModel editor

		<Package> --> Generate Example Class)


Running the generated Tests

*In Eclipse

	The Test can be run within Eclipse by, like the debugger, etc. creating a run configuration for it. A junit run configuration does not seem to accept environment variables etc, so you will need at least one for each project. It is possible to specify a directory, though, so multiple tests can be run from a single runConfig.

	Right clicking on the project and selecting 'JUnit Test' will CREATE a run configuration if one does not already exist.

 	The configuration can be configured to execute the tests using a number of Junit versions (3,4,5). As indicated above, the test cases generated by codegen are junit v3, but legacy support does seem to be available within the Junit5 runner, because the unmodified classes all seem to run fine too.

	The necessary JUnit libraries will need to be added into the Java Build Path (Project Properties).

 	Once properly configured, the test can be run by selecting the desired run configuration.

*In maven

	The test goal can just be invoked

		mvn test

	Providing codeGen has been configured to generate teh test cases in hte place where maven expects to find them (src/test/java by default), then the test cases will execute just fine.

	In order for the v3 Test Cases built be codegen to run, the Legacy Juliniut libraries will have to be inclused in the POM.

---
	<dependency>
		<groupId>org.junit.vintage</groupId>
		<artifactId>junit-vintage-engine</artifactId>
		<version>5.7.1</version>
		<scope>test</scope>
	</dependency>
---

	Although we will want to run most of our tests with Junit5, it is still useful to have the ability to understand Junit3 test cases : otherwise maven will reject all generated cases that we haven't yet converted to v5.


Generated Test Suites.

	In adddition to Test Cases generated for each class in your package, teh codegen tool will also generate a Test Suit type class (aometimes two.).   THe function of these to provide a conventient way of running all teh tests in a particaul packagee.

	However in practice these are more hinderance thatn help. Both maven and eclipse is capable of running all teh tests in a particular package without this classes being present. And if they ARE present, they will get run as well by eclipse/maven, resulting in every test getting run TWICE.

	It does not seem to be possible to disbale the generation of these tests cases, so they are best disabled by Anniotation as described below.




Converting the Generated V3 Test Classes to accept accept version 5 syntax features.

	It seems relatively easy to adapt the Junit v3 test classes to v5 in a way that DOES NOT get overwritten should the test class be regenerated. Obviously we don't wasnt to have to re-apply these changes each time the test cacse is regenerated.

	The necessary changes can be made in a custome fashion to each class if required, but to facillitate theis I have wtriotten my own little package to support this process.


*Add in junit3Stubs

	Ensure the support package is on the build path

---
		<dependency>
			<groupId>uk.co.pegortech</groupId>
			<artifactId>junit3Stubs</artifactId>
			<version>0.0.1-SNAPSHOT</version>
			<scope>test</scope>
		</dependency>
---


*Decorate your Test Class with the Parameter resolver

	The test class needs to be annotated with the name of our custom ParameterResolver (TestClassConstructorResolver). This is to tell it how to inject the required arguments into its constructor.

---
		/*
		 * @generated
 	 	 */
		 @ExtendWith(TestClassConstructorResolver.class)
		 public class CalculatorTest extends TestCase {
			 ...
		 }
---

*Annotate the constructor with our custom annotation

	This indicates that the arguments to the constructor are to be injected by the testing framework. The function that actually does this is provided by my junit3Stub package, as is the definition of the TestClassConstructor annotation.

---
		@TestClassConstructor(name = "tester")
		public CalculatorTest(String name) {
			super(name);
		}
---


*Disable the classes main() method.

	I'm not sure this is absolutely necessary, but it does make it certain that the tests are being run by the V5 runner, and not somehow using the TestRunner Class

	Comment out the main method call, and set main() as NOT generated. Otherwise, it will get get put back in the next time it is generated.

---
		/*
		 * @generaed NOT
		 */
			public static void main(String[] args) {
				//TestRunner.run(CalculatorTest.class);
			}
---


*Annotate the test class/methods as required by JUnit 5.

	The legacy v3 annotations such as @Ignore can be removed, and the various methods can be decorated with the V5 annotations as required. e.g

		@Test
		@ParameterizedTest
		@BeforeAll
		@Before

	Typically each testXXXX() method will need annotating with @Test

	The setUp method annotating with @BeforeEach

	The tearDown method annotating with @AfterEach


*Make sure the relevant packages get imported to the test class

	If eclipse is behaving itself, it will prompt you to import the missing paackages/classes, but you can pre-empt that yourself if you prefer.

---
	import uk.co.pegortech.junit3Stubs.*;
---

	The necessary v5 packages are likely to include:

---
	import static org.junit.jupiter.api.Assertions.*;

	import org.junit.jupiter.api.AfterEach;
	import org.junit.jupiter.api.BeforeEach;
	import org.junit.jupiter.api.Test;
	import org.junit.jupiter.api.extension.ExtendWith;
---

*Remove the legacy V3 packages

	Typically these will be:

---
	import org.junit.Ignore;
	import org.junit.jupiter.api.Disabled;
	import junit.framework.TestCase;
	import junit.textui.TestRunner;
---

*Ensure the junit3Stubs dummies are being used and then set the Class to @Generated NOT

	Confirm that wherever a junit 3 class is referenced ( TestCase, Test etc), that this get resolved to my dummy version (junit3Stub) rather than the pucka 'junit.framework' version.

	Annoyingly, the genmodel tool is very persistent about overriding what I put in here. Even with my own version of TestCase, it will realise that this exist on the build path, and instead substitute the fully qualified class name (junit.framework.TestCase).

	The only way I have found to stop this being overwritten is to annotate the CLASS with @generate NOT.

	so...

---
	* @generated NOT
 */
@ExtendWith(TestClassConstructorResolver.class)
public class FileServicesImplTest extends TestCase{
---

	HOWEVER this means that any new methods etc.. that get added to the class/interface DO not get a test case for them generated.

	The easiest way is to temporarily remove the @generate NOT annotation, re-generate the class, and then re-apply the changes that were backed out with the aid of the Compare-With tool. THIS IS REALLY A FANTASTIC TOOL

*Fix the Test Suite Classes

	The plan with these is to get them into a state whereby they don't interfere with anything and then disable them.

	These are fixed similarly to the above although there is less need to mess about with annotations. So:

	Remove the imports of the junit.framework classes:

---
		//import junit.framework.Test;
		//import junit.framework.TestSuite;
		//import junit.textui.TestRunner;
---

	..and import our own replacements:
---
	import uk.co.pegortech.junit3Stubs.Test;
	import uk.co.pegortech.junit3Stubs.TestSuite;
---

	...comment out the main method logic
---
			TestRunner.run(suite()); --> //TestRunner.run(suite());
---

	Disable further class generation;  and disable the class for Junit purposes with the @Disable annotation:

---
		...
		* @generated NOT
		*/
		@Disabled
		public class MainTests extends TestSuite {
---



Be wary of old Junit3 Assertions being used accidentally rather then the Junit 5 ones.

	The TestCase class that is extended by our test classes...

---
		 public class CalculatorTest extends TestCase {
---

	...also defines the set of assertions used in V3. These are NOT the same ones that V5 uses, BUT oftern have the same signature AND tend to be get used in prefernce to the V5 ones, which we will be preferring to use


	In order t be sure we pick up the correct V5 Assertion ( which are <<Static>>), make sure you provide the CLASSNAME too. e.g.

---

	Assertions.assertAll()

	Assertions.assertTrue()

	...
---


A brief description of the junit3Stub objects I have created

*The Class that does the actual parameter resolving.

	This class (TestClassConstructorResolver) need to implement the ParameterResolver interface. Here we are creating one which just injects the string "tester" into the constructor.

---
		package uk.co.pegortech.junit3Stubs;

		import java.lang.annotation.Annotation;

		import org.junit.jupiter.api.extension.ExtensionContext;
		import org.junit.jupiter.api.extension.ParameterContext;
		import org.junit.jupiter.api.extension.ParameterResolver;
		import org.junit.platform.commons.util.ReflectionUtils;


		public class TestClassConstructorResolver implements ParameterResolver {

			@Override
			public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
				// We invoke parameterContext.isAnnotated() instead of parameterContext.getParameter().isAnnotationPresent()
				// in order to verify support for the convenience method in the ParameterContext API.

				return parameterContext.getDeclaringExecutable().isAnnotationPresent(TestClassConstructor.class);
			}

			@Override
			public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
				//return ReflectionUtils.newInstance(parameterContext.getParameter().getType());

				return "tester";
			}
		}

---
	The class need to be dropped into the same package as the rest of your test classes.

*The Interface defining the annotation used to mark the constructor

	Codegen generates its Test Classes with a Constructor with one parameter. In general, v5 test classes are expected to have a no argument constructor, and so don't expect to have to supply one.

	This is more verbosely described in my onJUnit documentation.

	This is defined:

---
		package uk.co.pegortech.junit3Stubs;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;

		@Target(value= {ElementType.TYPE,ElementType.CONSTRUCTOR})
		@Retention(RetentionPolicy.RUNTIME)
		public @interface TestClassConstructor {
			 String name();
		}
---

	Note the @Target and @Retention annotations are important. They control where the annotation is valid. If this is incorrectly spec'ed, the annotation will fail silently at runtime.



Test Cases for Classes implementing Interfaces.

	If you model an entity explicitly as an Interface, and then model a class that implements that interface, the modelling tool will generate 2 test classes:

		An ABSTRACT class to test the Interface

		A Concrete class to test the implementing class.


	The methods in the interface will be present as test methods in each.

	Although the ABSTRACT class is generated, it is not actually RUNNABLE (because it is an abstract class, and NEEDS to be extended.)


	The most interesting way to make it runnable, is to have the test case generated for the implementing class EXTEND the abstract class for the interface so...

---
			...
			* @generated NOT
			*/
			public class FitStatOptionsTest extends OptionSetTest{...}
---

	When the test runner executes the test is the extending class, it will ALSO LOOK for tests in the extended class and run those also.

	HOWEVER THESE WILL BE LARGELY TESTING THE SAME FUNCTIONALITY.

	Consequently it is required to actually implement the tests ion only one of these place. IT makes sense to do it in the ABSTRACT class rather than the concrete class, because if more than one class implements the interface, the same code can be used to test ALL classes that implement it.


	It takes a little more manipulation of the implementing class in order to make this work.

	a)	BOTH test classes get implemented with a Fixture member for holding the object under test. THis need to be REMOVED from the implementing class

---
		/**
		 * The fixture for this Fit Stat Options test case.
		 * <!-- begin-user-doc -->
		 * <!-- end-user-doc -->
		 * @generated NOT
		 */
		 //	protected FitStatOptions fixture = null;
---


	b) The getters and setter fro the fixture need to be removed from the Implementing Class

---
		 * @generated NOT
		 */
  //	protected void setFixture(FitStatOptions fixture) {
	//		this.fixture = fixture;
	//	}

		 * @generated NOT
		 */
	//	protected FitStatOptions getFixture() {
	//		return (FitStatOptions) super.fixture;
	//	}
---

	This is to ensure when the fixture is manipulated by the Extending test case, it is the Fixture member of the Abstract extended class that is manipulated, NOT the local fixture.

	c) Ensure the test methods generated in the Extending test case that DUPLICATE test in the extended class are NOT annotated with @Test. That way they will get eignored by the test runner.

	d) Note that teh super class has no setup/teardown methods. These need to be implemented in the Extending class, nad annotated with @BeforeEach / @afterEach there ( if that is appropriate to the test scenario)
