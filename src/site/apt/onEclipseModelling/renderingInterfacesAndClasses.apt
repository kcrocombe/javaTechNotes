The rendering of Interfaces and Classes in Code.



Instance Class Name and Instance Type Name.

	These are two closely related things which are generally used to indicate that at Class/Instance is external to the model. The two terms, I believe, are necessary to properly represent {{{./onJavaLang.html#Generics}Generic Classes}}.

	If the Class is non-generic, the Instance Class Name and Instance Type Name will be the same.

	If the Class is a generic one (as most Collections are), then the Instance Type name will reflect the Parameterised Class Name. For instance, java.util.List\<String\>, java.util.List\<Apple\>, java.util.List\<Pear\>.

	The Instance Class Name will be the <<erased>> name of the generic. i.e. the way the Class will be represented by the compiler. This will usually be the <<raw>> class e.g. java.util.List. However, theoretically, it will the most specialised class capable of representing any of the possible Generic classes. For example, java.util.List\<Fruit\>.



How Providing Instance Names for Modelled Classes and Interfaces affect the artefacts generated.

*Choices in representing Classes/Interfaces in our model

	When modelling an application we will typically want to use objects drawn from three sources:

		* Objects created and contained in the package being modelled;

		* Objects created and contained in other packages within the model;

		* Object created and contained in package external to the project, e.g. standard Java Library packages or those from some other provider.


	The objects modelled, too, will of two major types:

	  * Classes

		* Interfaces


	In order to model these things, the ECore model provides the following facilities:

		* Choices as to how the Objects are modelled within Ecore. These are:

			* As Ecore Classes (Abstract or Concrete)

			* As Ecore Interfaces (always Abstract)

			* As Datatypes

			[]

		* An option to model the Class/Instance as an External Object by providing an Instance Class Name and Instance Type Name;

		* Generator Configuration choices:

			* to transform modelled classes into Instance/ImplementationClass combinations (the default, and 'right' way to go)

			* as direct classes alone.

			[]

		[]


	Each of these choices will be reflected in the way that the codeGenerator chooses to represent the model in terms of the actual, generated Java Classes and Interfaces. Since the generated classes/interfaces will need to be fleshed out into a full working application, it is important to ensure that these base building blocks form the best possible starting point for your application.

	A fundamental concept of the EMF modelling process that the ecore model and the generated classes/interfaces are different representations of the SAME underlying model. It should ALWAYS remain possible to both generate the code from the model AND generate the model from the code.

	If we are to respect this principle, it means we do not have the complete freedom to choose and mould the classes/interfaces that implement that model: we have to retain the generated skeleton, and flesh it out. If we don't we will lose the power to go transform code <---> model and vice versa.

	Therefore, in order to get the best possible starting point for our implementation, it is important to understand how the various choices we make in modelling get reflected in the classes/interfaces that are subsequently generated.


*Issues regarding EMF Functionality included in the generated model.

 	As has been noted elsewhere, the code generated by the EMF framework includes additional functionality 'for free' (Persistence, Notification, Reflective Services, etc.). The price we pay for this is that some supporting infrastructure needs to be built into each of the implementation classes, and some of this infrastructure can be difficult to decipher.

	Objects obtain this infrastructure typically by implementing particular ECore interfaces (and usually the Ecore Interface itself).

			* Where the generator generates Interfaces, the generated interface will specify the <<<Ecore>>> interface is implemented ( Do I mean inherited?);

			* Where the generator generates Classes, the generated Class will extend the <<<MinimalEObjectImpl.Container Class>>> (which implements the EObject Interface).

	Note that these are the Objects used by default. Within genModel, it is possible to configure the use of different base objects/interface,  but this can only operate at the level of the whole Model, not at the level of individual classes.


	 	EObject

		ClassWithNoInstanceName
		ClassExtendingClassWITHinstanceName





*Ecore model representation and their generated code form

	The following paragraphs tries to summarise how different modelling scenarios will be represented in the code generated. I have looked at the situation, firstly, with regard to how standalone classes/interfaces are represented, and then how classes involved in Inheritance relationships are modelled.

**Datatypes

	Datatypes are a simple way for external Classes and Interfaces to be referenced in the model. The fully qualified object name (Class/Interface) is associated with the named Datatype. The datatype name then just acts as a proxy and the actual class name will get 'expanded out' within the generated Classes/Interfaces.

***Principle Restriction

	The biggest shortcoming with using this as a representation of a Class/Interface is that it is very limited in the ways it can be related to other components of the model. Specifically:

		* They can't participate in any relationship (other than containment);

		* They can't participate in Inheritance Relationships;

	In practical terms they can only be used to as attributes with modelled Classes. i.e. effectively as contained Objects within a modelled class.





***Using GenModel with Default Settings (i.e. Interface plus Implementing Class).

****Standalone (un-extended) Classes/Interfaces

	The following describes how standalone, unextended classes/interfaces (i.e. no inheritance relationships) are likely to represented. The

[./images/classInterfaceGeneration.png]

	The table below indicates whether classes, interfaces or both will be generated both for natively modelled classes/interface (no Instance Class/Type name) and for External Classes (ones with a Instance Class/Type name).

	NB. For external objects, the designation Class/Interface reflects how the object is represented in the model. If it is represented as a class in the model, it does not mean that the external object actually IS a class.

*--------------------------------+----------*----------*-----------*-----------*
|                                | Internal | External | Internal  | External  |
|                                | Class    |  Class   | Interface | Interface |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Interfaces           |   X (1)  |     -    |   X (2)   |     -     |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Class Implementation |   X (3)  |   X (4)  |     -     |     -     |
*--------------------------------+----------*----------*-----------*-----------*

	Generated Signatures:

---
	1. public interface ClassWithNoInstanceName extends EObject {}


	2. public interface InterfaceWithNoInstanceName extends EObject {}


	3. public class ClassWithNoInstanceNameImpl extends MinimalEObjectImpl.Container implements ClassWithNoInstanceName {}


	4. public class ClassWithInstanceNameImpl extends MinimalEObjectImpl.Container implements \<TheNamedClass\>

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>
---


****Extended Classes/Interfaces


[./images/inheritance.png]

*****By way of Explanation

	In the tables that follow, an X will indicate that a implementing Class/Interface has been generated. Mostly these will have been generated in such a way that Ecore functionality is drawn in too. Where this DOES NOT happen, this is indicated in the table with an * instead. The number refer to the actual interface/class signature indicated in the block that follows.

*****Extending a Class

*---------------------------------+-----------------*----------------*------------------*----------------*
|                                 | Class Extending |    Extended    | Class Extending  |    Extended    |
|                                 | External Class  | External Class |  Internal Class  | Internal Class |
*---------------------------------+-----------------*----------------*------------------*----------------*
| Generated Interface             |       X (1)     |        -       |       * (2)      |      X(5)      |
*---------------------------------+-----------------*----------------*------------------*----------------*
| Generated Class Implementation |       * (7)     |     X (11)     |       * (8)      |      X (12)    |
*---------------------------------+-----------------*----------------*------------------*----------------*

	Generated Signatures:

---
	1. public interface ClassExtendingClassWITHinstanceName extends EObject, \<TheNamedClass\> {}

		<<NB This is syntactically incorrect - an interface cannot extend a CLASS!>>

	2. public interface ClassExtendingClassWithNoInstanceName extends ClassWithNoInstanceName {}


	5. public interface ClassWithNoInstanceName extends EObject {}


	7. public class ClassExtendingClassWITHinstanceNameImpl extends ClassWithInstanceNameImpl implements ClassExtendingClassWITHinstanceName {}


	8. public class ClassExtendingClassWithNoInstanceNameImpl extends ClassWithNoInstanceNameImpl implements ClassExtendingClassWithNoInstanceName {}


	11. public class ClassWithInstanceNameImpl extends MinimalEObjectImpl.Container implements \<TheNamedClass\> {}

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>


	12. public class ClassWithNoInstanceNameImpl extends MinimalEObjectImpl.Container implements ClassWithNoInstanceName {}
---



*****Extending an Interface

*---------------------------------+--------------------*--------------------*--------------------*--------------------*
|                                 |  Class Extending   |     Extended       |  Class Extending   |     Extended       |
|                                 | External Interface | External Interface | Internal Interface | Internal Interface |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generated Interface             |      X (3)         |        -           |       * (4)        |        X (6)       |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generating Class Implementation |      X (9)         |        -           |       X (10)       |        -           |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*

	Generated Signatures:

---
	3. public interface ClassExtendingInterfaceWITHinstanceName extends EObject, \<TheNamedInterface\> {}


	4. public interface ClassExtendingInterfaceWithNoInstanceName extends InterfaceWithNoInstanceName {}


	6. public interface InterfaceWithNoInstanceNmae extends EObject {}


	9. public class ClassExtendingInterfaceWITHinstanceNameImpl extends MinimalEObjectImpl.Container implements ClassExtendingInterfaceWITHinstanceName {}


	10.	public class ClassExtendingInterfaceWithNoInstanceNameImpl extends MinimalEObjectImpl.Container implements ClassExtendingInterfaceWithNoInstanceName {}
---



****Conclusions

*****Internal Classes

	[[1]] Following code generation, the internal classes will be represented as a Interface (of the same name as the modelled Class) and a Class that implements that interface.

	[[1]] The generated interface extends the EMF System Interface EObject by default.

	[[1]] The generated Class will extend an EMF System Object <<<MinimalEObjectImpl.Container>>>, as a means of implementing the EObject interface. As a consequence, we can not use inheritance as a mechanism to develop the functionality within our implementation objects. This is an undoubted drawback and is discussed further in a further section.


*****Internal Interfaces

	[[1]] The internal Interfaces will be represented as a single Interface extending EObject. It he modelled interface extends some other modelled object, it will extend the interface of that modelled object too.


*****External Classes

	[[1]] If you need to include an external class in the model, the only way to reliably model it is as a <<<Datatype>>>. Even then only Non-generic types can be reliably included. If you attempt to include a generic, it reduces it to its raw form within the implementation class (when really you need it to retain its generic nature intact, and as modelled).

	[[1]] If you attempt to model it as an External Class (i.e. a Class with Instance/Class Names), it will assume it is an External Interface and the generate a class which attempts to implement its 'interface' (which classes don't have, and so is syntactically garbage.)

	[[1]] If you attempt to model it as an external interface, then no Classes/Interfaces for it are created at all, which is what we want. However, should you attempt to EXTEND your modelled class, then class extending it will treat it as an interface and once again generate syntactically incorrect guff.


*****External Interfaces

	[[1]] The only external objects that can be reliably be modelled are Interfaces. Classes cannot (see above) the generate a class which attempts to implement its 'interface' (which classes don't have, and so is syntactically garbage.)

	[[1]] The external interface can be represented on the model as EITHER a Class OR an Interface. The objects generated will be differ:

		* When modelled as an Interface (i.e. the more natural way), the interface will have no direct representations of it generated at all (which is correct). Any Class/or Interface that extends it, will implement the external Interface directly. So if we are modelling the external interface List, ALL classes that extend it will need to implement functionality to implement List.

		* When modelled as a Class, no interface will be generated for it (since the interface already exists externally). However a Class to DIRECTLY IMPLEMENT that Interface WILL be created. ie if we model the List interface, a class ListImpl will be created that implements List. Any classes/interfaces that extend our modelled Interface will extend the DIRECTLY IMPLEMENTING  class AND implement the original, external interface. In contrast to the above, the List functionality would need to be implemented just once in the parent class. The classes that extend it would inherit the List functionality rather than having to implement it themselves.



***Using GenModel With Suppressed Interfaces.


****Standalone Classes/Interfaces

*--------------------------------+----------*----------*-----------*-----------*
|                                | Internal | External | Internal  | External  |
|                                |  Class   |  Class   | Interface | Interface |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Interfaces           |     -    |     -    |   X (1)   |     -     |
*--------------------------------+----------*----------*-----------*-----------*
| Generated Class                |   X (2)  |   X (3)  |     -     |     -     |
*--------------------------------+----------*----------*-----------*-----------*

	Generated Signatures:

---
	1. public interface InterfaceWithNoInstanceNmae extends EObject {}


	2. public class ClassWithNoInstanceName extends MinimalEObjectImpl.Container implements EObject {}


	3. public class ClassWithInstanceName extends MinimalEObjectImpl.Container implements <TheNamedClass> {}

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>
---


*****Extending a Class

*---------------------------------+-----------------*----------------*-----------------*----------------*
|                                 | Class Extending |    Extended    | Class Extending |    Extended    |
|                                 | External Class  | External Class |  Internal Class | Internal Class |
*---------------------------------+-----------------*----------------*-----------------*----------------*
| Generated Interface             |        -        |       -        |       -         |       -        |
*---------------------------------+-----------------*----------------*-----------------*----------------*
| Generating Class Implementation |       X (1)     |      X (5)     |      * (2)      |      X (6)     |
*---------------------------------+-----------------*----------------*-----------------*----------------*


	Generated Signatures:

---
	1. public class ClassExtendingClassWITHinstanceName extends ClassWithInstanceName implements EObject {}


	2. public class ClassExtendingClassWithNoInstanceName extends ClassWithNoInstanceName {}


	5. public class ClassWithInstanceName extends MinimalEObjectImpl.Container implements <theNamedClass> {}

		<<NB This is syntactically incorrect - a class can't implement a another CLASS!>>


	6. public class ClassWithNoInstanceName extends MinimalEObjectImpl.Container implements EObject {}
---



*****Extending an Interface

*---------------------------------+--------------------*--------------------*--------------------*--------------------*
|                                 |  Class Extending   |      Extended      |  Class Extending   |      Extended      |
|                                 | External Interface | External Interface | Internal Interface | Internal Interface |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generated Interface             |          -         |          -         |          -         |        X (7)       |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*
| Generating Class Implementation |         X (3)      |          -         |        X (4)       |         -          |
*---------------------------------+--------------------*--------------------*--------------------*--------------------*

	Generated Signatures:

---
	3. public class ClassExtendingInterfaceWITHinstanceName extends MinimalEObjectImpl.Container implements EObject, \<theNamedInterface\> {}


	4.	public class ClassExtendingInterfaceWithNoInstanceName extends MinimalEObjectImpl.Container implements InterfaceWithNoInstanceName {}


	7. public interface InterfaceWithNoInstanceNmae extends EObject {}
---

****Conclusions

*****General

	As you might expect, the objects generated when genmodel is operating in 'Suppressed Interface' mode are much more intuitive, though not completely so. In general, things modelled as interfaces get implemented as interfaces and things modelled as classes get implemented as classes.


*****Internal Classes

	As expected, these get implemented as a Class. Any Class the extends it also gets implemented as a class extending that class. The generated classes will Extend the EMF System object <<<MinimalEObjectImpl.Container>>>. So once again, wee can not use inheritance as a means of fleshing out the functionality in the implementation classes.


*****Internal Interfaces

	Again these behave pretty much as expected: a modelled interface will get implemented as a java interface, and once again, by default, these will implement the EMF system interface EObject.


*****External Classes

	Once again, it is NOT POSSIBLE to model external classes in such a way that hey will get sensibly reflected in the java code representation. Once again, the tooling behaves as if it is External Interfaces that are being modelled. As before, the only way to represent true Classes is to model them as Datatypes; and that restrict the extent o the modelling that can be performed.


*****External Interfaces

	[[1]] Things that get modelled as external interface will NOT be directly represented in the generated code at all, which is as it should be. Object that inherit from the external interface

	[[1]] However, as before, external objects that at REALLY interfaces but modelled as External Classes, will get modelled in the representation, but will be modelled as Interfaces.  The class will be named according to how it is named on the model and be a DIRECT Implementation of whatever external interface it references.
