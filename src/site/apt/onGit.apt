~~Header: blah blah
~~
~~Author
~~


The Git Version Control System

*About These Notes

	These notes have been compiled from a number of sources in order to explain to myself how to use git. Initially, the material summarises useful stuff I have read in books, notably:

	* Version Control with Git - John Loeliger : This is best reference I have on it.

	* Pro Git - Scott Chacon et al.

	[]

	However, I have also pulled in other stuff from the web and intend to continue to add little snippets of wisdom gleaned form the experience of just using the thing for real.


*Contents

	{{Basic Concepts}}

		{{Architectural Outline}}

		{{The Three File States}}

	  {{{./onDriesensBranchingModel.html}Vincent Driesen's Branching Model}}


*Basic Concepts

**Architectural Outline

	Architecturally, the biggest difference between git and, say, subversion is the way git things about its data. Systems such as svn store a set of files and a series of deltas on those files recording the changes made to file over time. (In svn's case, they  are reverse deltas: the most recent file is held and the previous files can be regenerated by 'subtracting' the delta from it).

	Git considers its data more like a series of snapshots on a filesystem. On a commit, it creates a snapshot of all the files as they look now. It does this by checksumming every file, and for any checksum that does not already exist in its database creates an entry for it and stores the associated file, compressed, as a blob within one of the repository structures.

	Note the Blobs are stored as pack files. The pack files are a way of storing several files of similar content together. Essentially common lines are stored once. Individual files can then be constructed by taking the common lines and then adding in the unique lines pertaining that individual file.

	The checksum algorithm used is SHA1 which generates a 160 bit (40 digit hexadecimal) number. Theoretically, it is possible for 2 files to have the same checksum ( a collision). However, the likelihood is vanishingly small : there are 10^48 combinations (a trillion people, producing a trillion blobs per second, for a trillion years would still only create 10^43 blobs.)

	There will also be a Tree object, which enumerates the files belonging to the snapshot and points to the blobs making up its files.

	There will also be a commit object, which holds a pointer to the tree object, pointers to the one or more commit objects that proceeded it (if a snapshot is created as a result of a merge, then it will have multiple parent Commit objects). The commit object also holds various metadata items describing the commit ( committer, date, email address, comments etc.)

	The other major object in the repository is the Tag object. A Tag object assigns a label to a specific object, usually a commit object.

	Nearly all operations on git are local : no information is passed to/from another computer. e.g. even browsing back the full history of a file is still a local operation because all of that is held within the local repository.

	It means you can work efficiently off-line.

	Very few operations actually remove data from the repository. Consequently, it is hard to do anything which completely messes things up.

**The Three File States

	Git has 3 main states that files can exist under:

		* committed - i.e. safely stored in the local database.

		* modified - changed in the filesystem but not yet committed to the database.

		* staged - marked (in its current version) for submission to the database in the next commit.

		[]

	These states are reflected in the 3 main architectural components of the repository:

		* the Git directory (.git) - is where git stores the metadata and object database for the project.

		* the working Tree - is a single checkout of one version of the project and exists in the normal filesystem. The files are pulled out of the compressed blob store in the repository.

		 * the staging areas - is basically  a file contained in the .git directory holding info of the files that will go into the next commit. Its technical name is the index. Linus Torvald argues that you can't fully appreciate the power of Git without first understanding the purpose of the index. It allows the developer to design the specific content of a commit, rather then just being the full range of files that have changed from the last commit (as svn does).

		[]

	NB - When a commit occurs, basically git just creates and stores a snapshot of the index, and daisy-chains it to its predecessor; little more than that.

	So the basic workflow is:

---
	modify files --> stage files --> commit files.
---

	Note that <<<svn>>> has no equivalent to the staging area.

	The command line is the most powerful way of using git. Although there are many GUI client, most of them do not implement the full range of git functionality.

===

**Branches and the Head

***Branches

 	We tend to think of a branch as a particular line of development, originating by forking from some earlier point in development and continuing till it is merged into another branch somewhere, or possibly continuing indefinitely. Whilst this is indeed the model that git support, when git refers to a branch it means something very specific. It  is useful to understand the git concept in order to fully comprehend the workings of git itself.

 	Technically, then, a branch in Git is simply a lightweight moveable pointer to the commit object at the end of a particular line of development. As commits occur on a branch, this pointer gets advanced in line with the terminal commit.

***The HEAD

 	The HEAD is a symbolic reference that points to a particular <commit>in the repository.  Its value will usually determine what branch you are "on". Remember, though that a <<branch>> is technically just reference to the <<terminal>> commit on a particular sequence of commits. Consequently, you are only "on" a branch if the HEAD <<does>> point to a terminal commit.

 	When you <<<checkout>>> or <<<switch>>> branches, then HEAD get updated to point at that branch.

***Commit Relative Names

 	If a given <<<branch>>> e.g. master refers to the terminal commit on a particular line of development, then:

 		* master^ - will refer to the parent commit of master;

 		* master^^ - will refer to the grandparent of the master.

 		* master^1 - will also refer to the parent commit of master;

 		* master^n - will also refer to the nth parent commit of master;

 		* master~n - will refer to the nth parent of master BUT ALWAYS FOLLOWING THE FIRST PARENT.

 	 []

 	<<Beware>>. Merging means that SOME commits have more than one parent, so it is not necessarily obvious which parent will be referenced in those circumstances.

***Detached HEAD State

 	It is possible, however, that the HEAD points to a commit which is non-terminal. In that case, the user is NOT working on any <branch>, but is working in what is known as <<<detached head>>> mode. i.e. the HEAD symbol is detached from the 'head' of the conceptual branch.

 	This is not an unusual situation: it will happen if you checkout a tagged commit from somewhere in the branches past, for instance.

---
 	git checkout v1.4

 	git status

		HEAD detached at v1.4
 		nothing to commit, working tree clean
---

 	Note: that it is perfectly possible to make changes and commits to files checked out in this fashion. However you will be in effect be creating a new fork in the development line WITHOUT a <<<branch>>> with which to refer to it: it will not be reachable except by using the SHA-1 hash of the commit object.

---
 	git checkout 7a7aa02d093c4d769477c98509f87dae3678e575
---

 	Consequently, it is usual to create a new branch when wanting to make changes when in <<<detached HEAD>>> mode. Branching will have the effect of re-attaching the HEAD to a branch (i.e to the branch just created).

*Basic Git Usage.

**Quick Ref

			The most commonly used git commands are:

				[add] Add file contents to the index;

				[archive] - Creates a tar or zip archive on standard out.

				[bisect] Find the change that introduced a bug by binary search;

				[branch] List, create, or delete branches;

				[checkout] Checkout and switch to a branch;

				[clone] Clone a repository into a new directory;

				[commit] Record changes to the repository;

				[diff] Show changes between commits, the commit and working trees, etc;

				[fetch] Download objects and refs from another repository;

				[grep] Print lines matching a pattern;

				[init] Create an empty git repository or reinitialise an existing one;

				[log] Show commit logs;

				[merge] Join two or more development histories;

				[mv] Move or rename a file, a directory, or a symlink;

				[pull] Fetch from and merge with another repository or a local branch;

				[push] Update remote refs along with associated objects;

				[rebase] Forward-port local commits to the updated upstream head;

				[reset] Reset current HEAD to the specified state;

				[rm] Remove files from the working tree and from the index;

				[show] Show various types of objects;

				[status] Show the working tree status;

				[tag] Create, list, delete, or verify a tag object signed with GPG.

===

**Documentation and Getting help

	Online documentation is available at the official {{{https://git-scm.com/}Git Website}}:

	* as reference material : {{https://git-scm.com/docs}}

	* as the  {{{https://git-scm.com/book/en/v2}Pro Git book (Apress)}}

	[]

	The manual pages are also good and can be accessed:

---
	git help \<gitCommand\>
---

**Configuration.

	git is highly configurable. Configuration information for git is held in 3 places:

		* /etc/gitconfig : contains values applied to every user of the system.

		* ~/.gitconfig: values specific to the particular user.

		* .git/config: values specific to a particular project.

		[]

	These files are manipulated with <<<git config>>> utility. e.g.

---
	git config --list --showorigin

	git config --global user.name "Kevin Crocombe"
	git config --global user.email kevin.crocombe@blueyonder.co.uk

	git config --global core.editor vi
---

	There are a huge number of configuration possibilities.

**Basic operations

***Creating and recreating a local repository

	A local repository can be created either:

	[[a]] from scratch, from within a pre-existing project dir:

---
	git init
---

	or;

	[[a]] from a pre-existing remote repository, either on the network somewhere, or on the same machine. e.g.

---
	git clone https://server/repository

	git clone file:///Users/kevin/Documents/GitHub/tester tester2
---

	(Note the file:/// construct)

	Obviously, you can't clone a repository that doesn't already exist, so ultimately every repository is created by <<<git init>>> somewhere in its history.

	By default the empty git repository is created as hidden directory called <<.git>> in the <<working directory>> of the current directory. If a directory name is specified, a directory of that name will be created and the .git directory created under that. i.e.

---
	git init

	git init <dir>
---

	 I have some issues with this layout as the repository directory <.git> forms part of the developers workspace and is at some risk of being accidentally deleted. It is possible to change where git creates the repository by setting the environment variable <<GIT_DIRi>>, but that then needs to be set and reset whenever you change projects.

	 A better way is to replace the .git directory with a .git configuration file. This is just a plain text file with a line:

---
	gitdir: /<dir>/<gitDir.git>
---

	This allows the LOCAL repository to be sited anywhere you like.

	This can all be specified to the init command when the repository is created or cloned.

---
	git init --seperate-git-dir=/users/gitRepos/kevin/<project>.git --shared=false <project>
 OR
	git clone --separate-git-dir=/users/gitRepos/kevin/<project>.git <repository> <project>
---

	The --shared=false qualifier sets the file-permissions on the project.git directory accordingly. We are not intending for this to be used by anyone other than the developer, so this will set permissions to 755.

	Note that on completion of the init, the repository is left in a slightly strange state: even though the 'master' branch exists, nothing has yet been committed on it. Consequently there is no commit object for the HEAD to point at. If you execute:

---
	git status
---

	This will indicate you are on the master branch. However:

---
	git branch --list
---

	will not show ANY branches at all.

	Attempts to create branches at this point, or check out files etc. will cause quite a cryptic message:

---
	fatal: you are on a branch yet to be born.
---

	Essentially, we need commit something to the master branch, and so create out first commit object to move forward.

****Re-running <<<INIT>>>

	<<<git init>>> is re-runnable. Consequently if we were ever to lose our working directory, (<project>) in the above example, we could recreate it just by running the same command again.

---
	git init --separate-git-dir=/users/gitRepos/kevin/<project>.git --shared=false <project>
---

	Obviously all the files will be missing from the working copy, and will, therefore, show on a <<<status>>> as deleted. Fortunately, these can be recovered by just <<<checkout>>>'ing once more:

---
	git checkout
---

***Making Changes to the LOCAL repository.


	[[1]] To begin tracking of a file within git

---
	git add <file>
---

	Note that the add command is used to both:

	* stage newly created files;

	* stage modified files.

	[]


	[[1]] Staging modified files for committal.

---
	git add <file>
---

	This will also work for directories. Note subdirectories do not have their own .git dir, unlikely subversion etc. ( except when sub-modules are involved.)

	Files can be un-staged using the <<<reset>>> command.

---
	git reset
---


	[[1]] Committing changes

---
	git commit
---

	Will prompt for a message by firing up the configured text editor.

---
	git commit -m "message"
---

	Will commit directly with the provided message.

---
	git commit -a
---

	Will skip the staging area and commit directly from the working copy.

---
	git commit --amend
---

	It is possible to amend a commit in some circumstances. e.g. if you've forgotten to add a file or something trivial like that. This amended commit will REPLACE the initial one.

	Note that the ID that a commit creates is GLOBALLY unique, not just within the repository, but across ALL repositories.

	It is also possible to cryptographically sign a commit. A cryptographic signature binds the commit to a particular real-world personal identity attached to the key used for signing; it verifies that the commit’s contents are the same now as they were when that person signed it, i.e. it guarantees that it has not been meddled with in any way.

---
	git commit -gpg-sign
---

	It is also possible to effectively discard a commit by rewinding the HEAD pointer to the previous commit. Note that this does not erase the commit, it just makes it inaccessible via the branch. You could still reference it via the commit objects SHA-1 hash. ( Or indeed, a tag if you had configured one.)

---
	git reset HEAD~
---

	It is also possible to effectively go back to a previous working directory state, but without actually undoing previous commits. Reverting a branch will reset the files in the working directory to how they were at a previous commit point, and then re-commit that previous state. The commit history will still exist as a regular commit line:

---
	old files ----> new files ----> old files
---

---
	git revert <tag> | <commit Id>
---


	[[1]] Removing files

---
	git rm <file>
---


	[[1]] Un-staging a files

---
	git reset HEAD <file>
---


	[[1]] Restoring files to the state they are in the current commit

---
	git restore <file>

	git checkout <file>
---

***Interrogating the state of the repository


	[[1]] Checking the status of the repository

---
	git status

	git status --short
---

	This will tell you which branch you are working on

	This will list the status of files under 2 categories:

	* Changes to be committed:

	* Changes not staged for commit:

	[]

	Note: it is perfectly possible for a single file to be in BOTH states. Remember when a file is 'add'ed, the specific revision is what is staged. Changes can still be made to the working copy file, but these don't automatically apply to the staged file.

	[[1]] Ignoring particular filetypes

	create a .gitignore file. Entries to this file are specified using the pseudo regex notation as follows:

---
	*.[oa]
	*.tmp
---

	Glob patterns are like simplified <<<regexp>>>s.


	[[1]] Viewing Changes made

---
	git diff

	git diff --staged
---


	[[1]] Viewing commit History

---
	git log

	git log --patch

	git log --patch -2

	git log --stat

	git log --pretty=oneline

	git log --pretty=full --graph
---


	[[1]] git show

	[[1]] git branch --all


***Extracting a bare working tree (i.e. not as a git repository.)

	The <<<git archive>>> command will cause the specified directory to be exported from the repository in the specified archive format. It is written directly as a stream  to <<<stdout>>>, where it can be captured as a file, or piped into some processing utility. Note it has to be run from within a git repository.

---
	git archive --format=tar -o <output.tar>

---

*Branching and Merging

**Introduction

	Branching means you diverge from the main line of development and continue to do work without messing with that main line. Essentially the line of development become forked, and development can proceed dow each line independently.

	Technically, a branch in Git is simply a lightweight moveable pointer to particular commit.

	When init creates the repository it creates the master branch automatically. There is nothing special about the master branch; it just happens to be what init calls it.

	As you make commits, the master pointer moves forward automatically to that new commit object (which will contain a pointer back to the previous commit). Creating a branch just creates a new named pointer to a commit on an existing branch.

	Generally a project will choose a particular branching model: this can be be as simple as a Master with simple development branches forking from it, or more sophisticated models such as that described by {{{./onDriesensBranchingModel}Vincent Driesen}}. Git itself provides no rules. You just need to adopt something that works for your project.

**Creating a branch

---
	git branch <test>
---

	This creates a new pointer to the same commit that you are currently on. Git knows what brach you are currently on because of a special pointer called HEAD which points to the latest commit in the 'active' branch.

	Note the above command creates a branch but does <<NOT>> change your active branch. To do that you must checkout to that branches

---
	git checkout test.
---

	This not only moves HEAD to the test branch but ensures the files within your working directory are refreshed so that their state reflects that indicated be the commit record.

	It is common to want to create a branch and move on to it at the same time. This can be accomplished with:

---
	git checkout -b <newBranch>
---

**Merging a branch

	The vast majority of branches will be short-lived, existing for only the length of time it takes to develop a feature, fix a bug etc.. At that point the branch will need to be merged back into the main line of development. Normally just 2 branches will be merged together, but it is possible to merge 2,3,4.. branches simultaneously.

	Note that ALL branches to be merged must be located in the same repository.

	To start merging, all you need to do is ensure your branch is cleanly committed.

---
	git status
---

	Then switch back to the target branch:

---
	git checkout <master>
---

	And merge in the branch.

---
	git merge <test>
---


	 If no other work has been done on the master branch since the point of branching, this will be a straightforward process. All that will happen is that git will 'fastforward' the master pointer to now point at the commit that you are merging back. Its that simple.

	 However, if other work has been committed on the master branch since branching, merging will require more work. In effect, git creates a new snapshot by merging:

	 	* the commit snapshot of the branch being merged in;

		* the commit snapshot of the branch being merged INTO;

		* the commit snapshot of the common ancestor.

		[]

  In most circumstances, the work done on the 2 branches will affect different files in different places, and so merging the changed files from the 2 branches will not pose a problem. In those circumstances all the needs to happen is to then {{{BranchDeletion}delete}} the now redundant branch.

**Merge Conflicts

	Occasionally the merge process will not go so smoothly. The same lines, or sometimes, just the same files will have been amended on both branches.  In these circumstances, git is unable to automatically merge the files and will call for some manual assistance. A message similar to the below will be issued:

---
	CONFLICT (content): Merge conflict in index.html
	Automatic merge failed; fix conflicts and then commit the result.
---

	You can see what files are in conflict:

---
	git status
---

	Any files that are in conflict will have been annotated with standard conflict-resolution markers showing the lines in conflict, the content, and the branch that they came from

---
	<<<<<<< HEAD:index.html
	<div id="footer">contact : email.support@github.com</div>
	=======
	<div id="footer">
	please contact us at support@github.com
	</div>
	>>>>>>> iss53:index.html
---

	Such conflicts can be resolved:

	[[a]] Manually. In which case, just edit the file to remove the conflict markers and leave in place the lines you wish to retained in the merged version. Then tell git that the conflict has been resolved.

---
	git add <resolvedFile>
---

	[[b]] Resolution using tool support. There are a number of tools that can help in removing conflicts from merged files. Providing you tell git which one you want to use, it will format the files in conflict so that they can be used by that tool.

	[]

	The tools available can be listed using:

---
	git mergetool --tool-help
---

	The following tools are available on my Mac:

		* meld

		* diffuse

		* diffmerge

		* p4merge

		* vimdiff

		[]

	To have a specific tool fire up, configure it into config file:

---
	git mergetool --tool-help
---

	 I have played around with a few of them and initially like the look of p4merge. To fire this up runs

---
	git mergetool --tool=p4merge
---

	Depending on the tool this may create a number of working files, but these ought to be deleted when the tool exits.

	The merged file now needs to be added and committed in order to complete the merged

---
	git add <resolvedFile>

	git commit
---

	There may be some backup files left behind by the tool. These should be deleted. The redundant branch can also now be {{{DeletingBranches}deleted.}}


	To merge branches, but effectively ignore any files on the target branch and use just use on the incoming branch.

---
 	git merge --strategy=ours
---

**Deleting Branches

	Once the work on a branch is completed and its content has been merged back into its parent or other branch, then the branch can be deleted.  By default, git will not allow you to delete a branch that has work which has not been merged. This can be overridden, if necessary, but this <<will>> mean that the work is lost.

	For purely local branches, it is normal to delete the branches after work is complete, but it is not required., Unlike svn, it is still possible to continue work on a branch after it has been merged back. Work can continue and further merges can be performed if that is what is desirable.

	However, if branches are being shared via an upstream repository, more consideration needs to be given as to whether a branch should be deleted or not, particularly if you delete the upstream branch too. If other people are using that branch on other server, you will have no direct visibility of that, but the removal of the upstream branch is likely to break the other repositories, temporarily at least.

	The branches on the system can be identified using:

---
	git branch --verbose
---

	Additionally we can display those branches which are either --merged or --no-merged and so identify candidates for deletion:

---
	git branch --merged
---

	When you are satisfied that the branch is truly redundant, it can be deleted:

---
	git branch -d <branch>
---

	Note that when a branch is deleted, it truly is deleted. Git does not maintain a historical record of what branches existed. The commit history of that branch will still exist, but commits that are not reachable from some named reference will eventually be garbage collected by git itself (via the <<<git gc>>> tool).

**Branch Graphs

	git comes with a graphical tool for visualising the branching structure of a particular repository.

---
	gitk
---

	It is also possible to view the branch structure using git log:

---
	git log --graph --pretty=full
---

====


*Tagging

	Git has the ability to label specific points in the a repositories history as of being particular significance. These are known as Tags. Typically, these are used to indicate release points etc. (Rel v1.0, v1.1, v2.0 etc).

	There are 2 type:

	lightweight - this is just a simple pointer to a specific commit. Use only for temporary things. (Many git commands do not work on lightweight tags.)

	Annotated - These are full objects within the repository. They are checksummed and contain the tagger, name, email address, comments etc. They can also be digitally signed via Gnu Privacy Guard (GPG). It is generally recommended to use annotated tags except for purely temporary things.

**Creation

	Create an annotated tag as follows:

---
	git tag --annotate -m "my version 1.4" v1.4
---

	This will tag the current committed state of the repository, with the given label.
	NB: by default git push does <<NOT>> transfer tags to remote servers; they will need to be explicitly published:

---
	git push origin <tagname>
---

	or, to push all tags

---
	git push origin --tags
---

	Like commit object, tag objects can also be cryptographically signed:

---
	git tag -s -a v1.2 9fceb02
---
	or

---
	git tag -u <keyId> -a v1.2 9fceb02
---

	Note that you can also tag commits <<AFTER>> you have moved past them

---
	git tag -a v1.2 9fceb02
---

**Deleting Tags
---
	git tag -d <tagname>
---

			Note again, that this does not delete tags from remote servers. This must be done explicitly:

---
	git push origin --delete <tagname>
---


**Checking out Tags

			To create a workspace with the files associated with a particular tag, you can check it out.

---
	git checkout <tag>
---

			Note that it is perfectly possible to make changes to the files checked out AND recommit them. However this will not affect the commit that the tag points at. The new commit won't belong to any branch ( it is detached from the HEAD), and will therefore be largely unreachable. (You can reach it by querying for the exact commit hash.)

			Therefore, if you do want to make changes to a checkout tag, you need to create a new branch from it.

---
	git checkout -n <new branch>
---
===

*Working with Remote Repositories

**Repository concepts

	A Git repository is either a bare or a development (non-bare) repository.

	[[a]] A development repository is used for normal, daily development. It maintains the
notion of a current branch and provides a checked out copy of the current branch in a
working directory.

	[[b]] In contrast, a bare repository has no working directory and shouldn’t be used for normal
development.A bare repository has no notion of a checked out branch, it is simply a subset of the contents of the .git directory. In other words, you can't (or shouldn't) make commits on a bare repository.

	A bare repository may seem of little use, but its role is crucial: to serve as an
authoritative focal point for collaborative development.


	A bare repository:

		* has no working directory

		* has no reflog (basically a record of the commits)

		[]


**Clones

	When using git clone to create a new repository, not all the information in the source repository is reproduced in the clone. And conversely, the clone can contain some information that does not appear in the source.

	Things not cloned include:

		* remote tracking branches;

		* local development branches (These become remote tracking branches in the clone);

		* objects that are not reachable from any of the cloned references.;

		* All repository-specific info:

		 	* hooks;

			* configuration files;

			* the reflog;

			* the stash;

			[]
		[]


	Things added into the clone include:

		* a link back to its parent via a remote called origin;

		* remote tracking branches for the local branches in the origin.

		[]

	Remote repositories are versions of your project that are hosted on the Internet or network somewhere, or even locally on the same machine.

	You can have several

	Collaborating with others involves managing these remote repositories and pushing and pulling data to and from them when you need to share work

	To see what remote repositories have been configured in to your local repository, use:

---
	git remote -v
---

	Unless your repository is a complete standalone repository (built using git init) you are likely to see:

---
	origin	https://github.com/kcrocombe/desktopRep.git (fetch)
	origin	https://github.com/kcrocombe/desktopRep.git (push)
---

	This suggests this repository was cloned from a GitHub repository. There is nothing special about 'origin': it is just a convenient shorthand reference to the url of the remote repository.

	It is possible that a repository will have several remotes configured into it.


	The significance of the remote repositories is that it means we can pull development contributions from those remote repositories, and potentially have permission to push our development contributions back.


	We may add new remote repositories as and when the need arises:

---
	git remote add <name> <url>
---


**Tracking Branches.

	Remember; a branch is just a symbolic reference to the commit object at the HEAD of a particular line of commits.

	However, its important to realise that there are different categories of branch, and that an understanding of the purposes of each is essential once we start working with remote repositories.

		* Topic or Development Branches - any local branch which is not tracking a branch in a remote repository. If you have a standalone repository, not connected to any remote, then all your branches will be of this category. They are locally Read-Write.

		* Local-Tracking Branches - are local branches that have an equivalent in a remote repository somewhere. They are branches where work is performed locally, but with the intent that that work will make its way back into the remote equivalent. They are locally Read-Write.

		* Remote Tracking Branches - are also local branches, and also have an equivalent in a remote repository somewhere. They are branches whose purpose is to reflect locally the current state of the remote equivalent. i.e. as other people commit work on the remote branch, branch will get updated to reflect that work. IT DOES NOT INCLUDE ANY WORK PERFORMED LOCALLY.  A Remote Tracking Branch will be paired with a Local tracking branch. When the local user wishes to incorporate commits done remotely, the Remote Tracking Branch serves as a local source of those commits, and so can be merged in to the local tracking branch in the usual way.

		<<Note: Remote Tracking Branches should be treated as READ-ONLY. It is possible to write to them, but you can severely screw things up if you don't know what you are going. It is OK to checkout on a Remote Tracking Branch, but you should <<<NOT>>> perform Commits or Merges>>

		* Remote Branch - these are NOT local. They sit in remote repositories, and so are not directly accessible. They are likely to be the target of a Remote Tracking Branch.  However, the


	Local and Remote Tracking Branches are often set up automatically by git when it performs certain operations. For instance:

		clone - will set up a <local tracking branch> and <remote tracking branch> for each branch in the repository that is being cloned.

		push - if you create a new branch locally, push, with the --set-upstream \<remote\> \<branch\> will create the branch on the remote server and create <remote tracking branch>, and register the branch as a <local tracking branch>.

		pull - If any new branches have been set up on the server, pull will create a new branch locally and register it as a <local tracking branch> and also create a <remote tracking branch>.



**Setting up an initial Depot repository.

***Introduction

	A depot repository is not technically different from any other repository: the term Depot merely describes its purpose. A Depot repository is basically the one that all developers consider to be authoritative. Consequently every development project where developers are collaborating will have just ONE depot repository.

	All developers will use the depot as the <remote origin> for their own repositories.

	Obviously, therefore, the depot will be on some form of shared infrastructure, and most likely on a server somewhere.

	Note: just because a repository is remote does not make it a depot: it has to be TREATED as one.

	The below works through the process of setting up a depot on GitHub, cloning development repositories from it, performing parallel development on it, with those changes being periodically pushed back to the repository.

	There are several ways that this could be done: it is possible to create the depots repos directly on Github itself and then clone from there. For this example, we will create the depot repository locally in the first instance and then deploy it to the server.


***Creation of an initial local repository

	Initially we will create a repository that we can initially work with. This is so we can add some initial structure to the repository, and some initial files. Consequently, we don't use the --bare qualifier.

	Once again, we are creating the .git directory way from the working directory.

---
	cd dvl/gitClones

	git init --separate-git-dir=/users/gitRepos/kevin/sharedProject.git --shared=false sharedProject
---

	The master branch will have been created at this stage, but, in the parlance, will not be born until the first commit object has been created for it to point to.

	Consequently, we need to add out first file.

---
	git add README.txt
	git add RELASE.txt

	git commit -m "Initial master Commit"
---

	We can now see the master branch:

---
	git branch --list
---


	At this point we can add a second permanent branch for the development line.

---
	git branch dvl
---

	This can now act as the basis as our depot.

***Creating the Depot Repository from the local repository.

	A depot repository will alway be remote when viewed from the perspective of a development repository, but that does not mean that that remote depot repository will be on a different machine. It is perfectly possible for a depot repository to be on the same machine as the development repository, or on storage shared between machines.

	Although it would be more usual for a depot to exist on a remote server, how to set up both locally-hosted and remote-hosted repositories is covered below.

****Building Depot on a local machine
---
	cd sharedProject

	git clone --bare . /users/gitDepots/kevin/sharedProject.git

	git remote add localDepot /users/gitDepots/kevin/sharedProject.git

	git remote --verbose

				localDepot	/users/gitDepots/kevin/sharedProject.git (fetch)
				localDepot	/users/gitDepots/kevin/sharedProject.git (push)
---

****Building the Depot on a remote servers

	Most depot repositories are likely to be built on remote servers, and this creates and immediate difficulty. It is not possible for native git to create a repository on anything other than the machine it is running on. This means that in setting up our depot repository on a remote machine we need to either:

		[[a]] logon to the remote server in some way and run 'git init'  locally there.

		[[a]]	copy the operating system file making up a bare clone git from the local server to the remote server.

	The first of these methods has effectively already been covered, since it is little more then the method used to set up a depot server locally. Once the <<<git clone>>> was completed we need to move the <<<sharedProject.git>>> file to it new host server.

	For the rest of this, we will walk through the steps necessary to create a depot repository directly on a particular remote service, namely on GitHub.


****Getting init run the Github server.

	There are 2 ways that this can be accomplished:

	[[a]]  via the web site;

	[[b]]	 via the GitHub command line tools (or via the GitHub Desktop tool, which is not covered here)

	[]



*****Using the Hub Command Line Tools

	Github provide a command line interface (called hub) to its git services which allow repositories to be created/managed/deleted from a command line client. It behaves like a wrapper to git : all git commands are available in hub. In effect, it extends the functionality of git.

	This has the advantage of allowing steps needed to set up and maintain a repository to be scripted.

	The tool was installed via brew as follows

---
	brew install hub
---

	It can then be used to create a new repository on GitHub itself. It requires that an initial local repository is created and then uploaded via the tool.

	Connections to GitHub must be authenticated in some way. To avoid Github challenging for passwords etc. use either the HTTPS protocol or the SSH protocol.  Both of these options require some configuration to be done on GitHub first. Namely:

	* For SSH, a ssh key-pair needs to be generated (described elsewhere) and the public key uploaded to Github as part of the repository owner account configuration.

	* For HTTPS, a Oath2 Token for the repository owners account needs to be generated and this registered with the osxkeychain. This is more fully described elsewhere. git also need to be configured to use the  osxkeychain as its credential helper. This is more fully described {{here}}.

	By default, the <<<hub>>> application looks to use SSH by preference, although for day to day operations HTTPS is the preferred protocol. To avoid difficulties it is probably better to ensure both methods are available before setting up any repositories. Note the below is not a 'per-repository' type configuration. Once configured in for the user it will have effect across all repositories.

---
	git config --global credential.helper 'osxkeychain'
---

	Add in the <<origin>> of the remote repository, specifying an <<<https://>>> protocol. If we do not do this, the <<<hub create>>> step will create one, but using the default <<<ssh://>>>

---
	git remote add origin https://github.com/kcrocombe/sharedProject.git
---
	Now create the repository on GitHub using this as the source repository. Make sure you are in the <<<sharedProject>>> directory before running.

	The below example will create a private repository, with the indicated Description.

---

	hub create -p -d "some shared project description"  [-o]
---

	This will respond with the URL of the created repository. This should be the same as the remote <<<origin>>> that you configured in a previous step.

	The -o option can be specified. This is quite useful, and will cause the repositories configuration page to to be opened in a browser.

	Many repositories will benefit from a bit of further configuration.


*****via the Web site

	In many ways using the web-site is pretty easy. Its only real drawback is that it is not amenable to scripting : you are interacting with a graphical interface. This is the general process

			find the button that says 'create' a new repository.

			supply repository name, description, public/private only.

			DO NOT initialise the repository with any files, since we will be importing the repository.

			Hit the 'Create' Button.

			Note the URL that should be used to reference the new repository.

	We are now done with the GitHub site. The repository has now been created, and should be in the 'init' state. We can now perform all further actions from out local machine.


****Configure the remote reference

	 Because our original repository was created as an init rather than a clone, it will not have the 'origin' remote configured in. (The clone command configures this in automatically). We can add this in manually. This now makes the local repository look like it has been cloned from the  remote repository even though it was actually the other way round.

	<<<
		git remote add origin https://github.com/kcrocombe/sharedProject.git
	>>>

****Push up the local objects to the remote

	The remote database is currently in the init state, with no objects, references etc. So now we need to push our existing objects up to the remote (called origin). For this we use the <<<git push>>> command.

	By default, this will only send the objects on the current branch, but we will want to send the objects on the development branch too. Hence the -all qualifier.

	The --set-upstream qualifier causes a mapping to be created in our local configuration. It essentially registers the local branch (master in this case) as a local tracking branch for the remote branch (master). It also creates a remote tracking branch remotes/origin/\<branch\> to keep track of the current state of the remote branch.

	Now whenever we attempt a pull/push on our local branch it knows which remote branch it is trying to fetch/push data from without being explicitly told.

	So, first dry-run it:

---
	git push --set-upstream --all --dry-run origin
---

	Then do it properly:

---
	git push --set-upstream --all origin

			Enumerating objects: 6, done.
			Counting objects: 100% (6/6), done.
			Delta compression using up to 8 threads
			Compressing objects: 100% (3/3), done.
			Writing objects: 100% (6/6), 528 bytes | 264.00 KiB/s, done.
			Total 6 (delta 0), reused 0 (delta 0)

			To https://github.com/kcrocombe/sharedProject.git
			 * [new branch]      dvl -> dvl
			 * [new branch]      master -> master

			Branch 'dvl' set up to track remote branch 'dvl' from 'origin'.
			Branch 'master' set up to track remote branch 'master' from 'origin'.
---

		This creates:

			2 new branches in the remote repository:
						master
						dvl

			2 new tracking branches in the local databases
						remotes/origin/dvl
						remotes/origin/master

		This completes the setup of the repositories. We now have a local developer repository and a remote depot repository on Github that are perfectly in Sync.

***Synchronising new local feature branches with the depot repository.

	It will be commonplace to create feature/topic/working branches in your local repository as part of the normal development lifecycle. It may be that these branches can remain local your repository : if you are able to merge back into the parent branch, and have the necessary permissions to push the parent back to the depot, then your working branch can remain local.

	Often, however, there are restrictions place on who can merge back into the more important branches. Also it may be that you wish to work collaboratively on your branch.

	In these circumstances, you will need to push your new branch to the depot, creating a <remote tracking branch> for it and registering it as a <local tracking branch>.

---
	git push --set-upstream origin <local branch>
---

====

**Working with Repositories and their remote Depots.

	In large part, working with remote repositories is no different from working with your own local repository. You still have branches that you check out work on, make edits and commit transactions. The only difference is that some of those branches will be copies of, or based on, branches in OTHER repositories.

	Because work may be preceding in parallel with work in those remote repositories additional steps will be required to ensure that synchronicity between the repositories is maintained over time.

	Key to this are the concept of the <remote tracking branch> and <local tracking branch>. Each of these, in different ways, will reflect the state of a branch in a remote repository somewhere.

	The <local tracking branch> is a representation of the remote branch that the developer is free to work on. He may checkout and commit to it, branch from it and generally treat it as if it was his alone. When the branch is initially created it will reflect the exact same state as the remote branch on which it is based, but from then on it will diverge form it as work is done.

	The <remote tracking branch> at the time of its creation will also reflect exactly the state of the branch on which it is based. However the developer <<SHOULD NOT>> perform any active work on it : it should be treated as <<readonly>>. The point being is that it should <<ALWAYS>> reflect the last known status of the equivalent branch in the remote server. As work progresses on the remote branch, this should update to reflect that.

	This does not happen automatically.

***Pulling

		The <<<pull>>> command is the principle way that a developer keeps his various tracker branches in line with what is happening on the remote repository.

		Pull fundamentally does two things:

		* It <<<fetch>>>'es  any work done on the remote branch since the last <<<pull>>> and applies it to the <remote tracking branch>.

		* It <<<merge>>>'s the work on the resultant <remote tracking branch> into the <local tracking branch>.

		[]

		Each of these steps,  is supported by a command in their own right: <<<merge>>> and <<<fetch>>> . This allows the developer to keep their <remote tracking branch> up to date, while having full control as when those changes are incorporated into the branch on which they are working.

****Fetch Step

		The fetch step first identifies the remote repository and which branches in the repository are to be fetched and which <remote tracking branch> the work is to be added to.

		This information might be provided to the command as parameters on the command line, but more usually it will not be specified.  In these circumstances, git will consult its configuration to see what default has been copied in. This will be configured in terms of a {{RefSpec}}, and will be usually something of the forms

				+refs/heads/*:/refs/remotes/origin/*

		which basically maps each <local tracking branch> to a similarly named remote branch.

		The missing commit objects, blobs etc. are downloaded, as are the missing reflog entries (.git/logs/refs/*)

		Once the <local tracking branch> is amended to reference the new latest commit-object, then the fetch is complete.

****Merge Step

		This is pretty much just a standard merge that has been discussed  before. Once again, in the absence of any explicit source/target in the command line, it will use sources inferred from the default refspec in the configuration file.

**Push

	Push is the corollary of the Fetch Step: it essentially updates the remote branch with the contents of the <local tracking branch>. Note that it also updates the local <remote tracking branch> too, so that these two things still remain in step.

	Note: it is <<not>> possible to <<<Push>>> to the remote database, if your <local tracking branch> and <remote tracking branches> have not yet fully incorporated the latest commits from the remote database.

	In other words, if someone else has <<<push>>>'ed to the remote since the last time that you <<<pull>>>'ed then your <<<push>>> will fail.


**Good Practice

	Note : not all pulls/merges will go smoothly; with parallel development some clashes are bound to happen from time to time. Consequently, it is a good idea to keep your local branches as closely aligned with the remote branches as possible.  Frequent <<<pull>>> / <<<push>>>'es are a good idea as it then keeps the degree of deviation as low as possible, and makes any merges clashes smaller and easier to resolve.




**Access Control

	There is none! Git itself does not provide any means of graduating access to the files that it manages. For local repositories,  some degree of control is available by controlling operating system permissions on the repository files. But for network resident repositories, git offered nothing.

	Most git providers will layer a degree of security on top however, although generally only the fairly basic features are provided without charge.

	In GitHub, private repositories cannot be further protected, but they are accessible ONLY to the owner and the registered collaborators (i.e. collaborators have push access to the repository).

	Public Repositories can have limited protection rules applied to one or more of their branches. In practice, the protection afforded is to enforce a workflow model that requires review and approval before work can be pushed/pulled to repository branches. In practise, though that IS quite a powerful protection.


	Github also allows repositories to be owed by organisations. For the Free Package, such repositories must be public ones, but it does allow you to set up a register a set of users , and then control who can do what on which branches. If this was available on private repositories, then this would be my preferred option I think, but at the moment, don't want to make too much stuff public.


**Providers of Git Services

	* {{{https://github.com}GitHub}}

	* GitLab

	* SourceForge

	* Bit Bucket


**Deleting Remote Repositories

	This can non be done remotely via git. It needs to be done on the remote server itself.

	or with hub tool

**Working with Github

	Desktop tool - useful for working with local repositories, but doesn't manage the remote repositories. Seem to log into the web service itself for that.


***Free Plan.

	This now seems to allow:

	* unlimited public repositories;

	* unlimited private repositories;

	* 3 collaborators on private Repositories;

	*	Issues and Bug Tracking.


**Enabling Seamless Secure Connection to the Remote ServerSide

	In general, connection to the remote server will require to be authenticated. Some operations may not : public access to public repositories for instance, but in general some form of credentials will need to be passed to the server in order for communication to proceed.

	The more widely-used transfer protocols (SSH, HTTPS) will prompt for the necessary credentials ( username/password) before permitting data exchange.  This is inconvenient in a number of ways, not least if you are using long, secure passwords.

	Fortunately, it is possible to configure the client to hold and pass the necessary credentials seamlessly.

	For SSH, this is done via the usual public/private key pairs, but since we won't be using that I won't discuss it further.

**For HTTPS

	Https does not allow authentication via key-pairs - every connection requires a username password. Fortunately, git has a build in credentials system that can hold the username/password and pass them as required automatically. There are a number of systems ( 15min memory cache, plain text store etc) but the one that makes most sense on the Mac is to configure the credentials within the OSX keychain.

	First tell git that that is the credential mechanism  you wish to use:

---
	git config --global credential.helper 'osxkeychain'
---


	Then create a keychain entry (Internet password) for https://github.comp

			Name: github.com

			Kind: Internet password

			Account: kcrocombe

			Where: https://github.com

			Password: *******   (but see {{TwoFactorAuthentication}}Two Factor Authentication} below).

	When saving this it will prompt you for the password of the mac user who is going to use this.

	Now when communicating with the remote server, git will send these credentials.

**Two Factor Authentication.

		The introduction of 2-factor Authentication mechanisms for Github accounts has added a layer of complication to this process. Under this regime, the normal password for the account is not enough. Additionally the user has to supply a secondary, generated code ( usually via a app on a smart phone.)

		In these circumstances, the standard password will not work. Instead, you must use a personal access token.

**Personal Access tokens

		Personal Access Tokens are similar to OAuth access tokens, and are generated and managed on the GitHub site itself (under Developer Settings). They are for the exclusive use of one connecting app only.

		This token must be configured into the keychain instead of the password.

		Note that the token issued (Personal Access Token') are endowed with a level of privilege (scopes). Consequently you will not, by default, be able to perform the full range of operations that you would if authenticated directly. However, granting just 2 'scopes' should enable most day to day things to be accomplished. These are:

			* repo ( Control of Private Repositories)

			* delete_rep ( Ability to delete repositories )


===

*Stashing


*A popular Branching Model.


*Ref specs

 A ref is just a SHA1 hash ID (e.g. d0f02e043ea9110002a1f1169517da18d3acc805) that refers to an object in the git Object store.

 Since users find these difficult to handle, the system creates symbolic references(symref) for them. These are just plain files held under the \<refs\> subdirectory of the .git directory structure.  There are 3 subdirectories:

 	* refs/heads  -  pointing to the commit object representing a particular LOCAL branch;

	* refs/remotes - pointing to the commit object representing a particular <remote tracking branch>;

	* refs/tags - pointing to the object representing a particular  tag.

	A refspec maps branch names in a remote repository to branch names in a local repository. It takes the forms

---
	[+]source:destination
---

		where source and destination are symbolic references e.g.

---
	+refs/heads/branch1:refs/remotes/remote1/branch1
---

	They can take wildcards:

---
	+refs/heads/*:refs/remotes/remote1/*
---

	which maps every branch in the local repository to a branch of the same name in the remote repository remote1.

	Operations like <<<push>>>, <<<pull>>>, <<<fetch>>> require a refspec to operate on. If one is not provided, then it uses the default one in the config files ( usually <<<+refs/heads/*:refs/remotes/origin/*>>>)


*Pull Requests

	This seems to be a feature associated with GitHub, rather than anything core to git itself. In essence it is part of the control process to ensure that nothing gets merged into the important branches of git without the review and approval but some notional owner.

	Native git, at least on remote servers, has no means of restricting what users can perform what on a branch: anyone can push anything to a remote branch. If you want to impose discipline and/or any sort of QA process, that raises obvious difficulties.

	Web based Git-services, such as GitHub can layer extra protection on top. GitHub allows two forms of repositories to be created:

		* Private - readable and writable just by the owner and a defined set of collaborators

		* Public - readable and writable by anyone.

	In order to afford some level of protection to public repositories, GitHub will allow additional protection to be applied at the branch level. (This can be used on private branches too, but only under their <Paid For> plans.)

	There are a few protections that can be put in place on a branch, but the one that is most often to be used is one that <Requires Pull Requests Reviews before Merging>.

	 <Requires Pull Requests Reviews before Merging> enforces:

	 * that all commits be made to a non-protected branch in the depot repository;

	 * that merge requests from that branch to the protected branch be via a GitHub feature known as a Pull Request;

	 * that the Pull Request must get approval from at least 1 approver;

	 * that no changes are made to the branch in between the Pull Request and the Merger.


	 In practise, that means nothing can be committed/merged back into the depot repository branch without the say-so of the repository owner or other administrator.

	 <<NB: This does not prevent the user of the local repository from committing changes on their <local tracking branch>.  However if they then try to push that back to the depot repository the push will be prevented.>>


	 Once the <Pull Request> has been proved, the <local tracking branch> in question can be merged back in to the branch. This can be performed


	  suspect that behind the scenes, this functionality is implemented via git hooks.

	 The issuing and processing of <Pull Requests> must be administered via the GitHub site, although it is possible at least to raise a pull request via the <hub> command line tool.



	Essentially a developer should have branched from a master or other core branch in order to develop a new feature, fix a bug etc. When complete,

	There is a <<<hub>>> command utility that allows these to be raised from the command line. It can be called with various arguments, but in many ways, calling it with the following is probably the easiest.

---
	hub pull-request --edit --message "Some Message"
---

	This will open a text editor for details to be amended in a simple form. Once the user exits, the request will be submitted.




*Keeping Local/Remote Repositories in sync with Created/Deleted Branches.

**If a branch is created locally on a repository

---
	git branch newLocalBranch
---

	This does NOT get automatically created on any remote servers. If we try and <push> it:

---
 	git push
---

	this will fail and inform us that the branch has no upstream branch..

	We can create the branch by pushing as follows

---
	git push --set-upstream origin newLocalBranch
---

	As well as creating the branch in the remote branch, it will locally create a <remote tracking branch> origin/newLocalBranch and also register the local branch as a <local tracking branch>



**If a branch is created centrally on a remote depot server
---
	git branch newDepotBranch
---

		(or via the Web Pages, if using GitHub)

	This does not automatically get propagated to any of the local servers that use that remote server. If we try and <pull> from the remote, however:

---
	git pull

---

	This will create a new local <remote tracking branch> origin:newDepotBranch. However, it will <<NOT>> create a new <local tracking branch>

---
	git branch --all

		* master
		  remotes/origin/master
		  remotes/origin/newDepotBranch
---

	However if an attempt is made to checkout newDepotBranch

---
	git checkout newDepotBranch
---

	This will create a new branch <newDepotBranch> and register it as a <local tracking branch>

---
	git branch --all

	 master
 * newDepotBranch
   remotes/origin/master
   remotes/origin/newDepotBranch
---


**If a <local tracking branch> is deleted on a local REPOSITORY

---
	git branch -d newLocalBranch
---

 This will delete the <local tracking branch>. However it will not delete either the remote repository that is tracking or the local <remote tracking branch>.

---
	git branch --all

  master
* newDepotBranch
  remotes/origin/master
  remotes/origin/newLocalBranch
  remotes/origin/newDepotBranch
---

	<<NB. If a checkout is now executed, the <local tracking branch> will be re-created>>


	To additionally delete the remote repository, we must push the delete to the origin:

---
	git push origin -d newLocalBranch
---

	This will delete <<BOTH>> the remote repository AND the <remote tracking branch>.

---
	git branch --all

  	master
	* newDepotBranch
  	remotes/origin/master
  	remotes/origin/newDepotBranch
---

	Alternatively, if we don't want to touch the remote repository (because someone else is using it), we can just remove the <remote tracking branch>

---
	git branch -d -r origin/newLocalBranch
---

---
	git branch --all

  	master
	* newDepotBranch
  	remotes/origin/master
---


**If a branch is deleted on a remote depot repository

  On the remote server:

---
	git branch -d newDepotBranch
---

		(or via the Web Pages, if using GitHub)

	This will NOT affect ANY <local tracking branch> or <remote tracking branch> on ANY repository using it as a source. We can still commit to the <local tracking branch>

---
	git branch --all

  	master
	* newDepotBranch
  	remotes/origin/master
---

	However, if we attempt to pull from the deleted repository, it will fail:

---
	git pull

			Your configuration specifies to merge with the ref 'refs/heads/newDepotBranch'
			from the remote, but no such ref was fetched.
---

	 If we attempt to push to the deleted repository

---
	git push
---

	 It will <<re-create>> the remote repository and populate it with any new objects from the local branch.

---
	git branch --all

  	master
	* newDepotBranch
  	remotes/origin/master
---

	 	However, if we wish to remove the local branches in order to to keep our local repository in sync with the remote depot, we need to:

			Remove the <remote tracking branch>

---
	git branch -d -r origin/newDepotBranch
---


			Remove the <local tracking branch>

---
	git branch -d newDepotBranch
---

---
	git branch --all

  	master
  	remotes/origin/master
---



*Aborting or Restarting a Merger

---
	git reset --hard ORIG_HEAD

	git reset --hard HEAD
---

*Pull Requests

---
	hub pull-request --base kcrocombe:master --head kcrocombe:fix
---


*What does the hub sync command do

		create a fix branch

		request a merge on That

		d


		Git hub doe snot allow server side hooks.



*Sub-modules

	This looks like quite an important feature to understand. However for now, I just note that the feature exists and will come back to make notes on it later on.

	The books I've read suggest that this feature is a bit clunky in earlier versions. Hopefully it will be a bit more stable now. Even so, I understand it is a bit tricky to use.

	NB. It only really makes any sense to use sub-module in your project if you expect to be making change to it. If you are just USING the files PROVIDED by a sub-project, then you are better NOT to build it into your source, but do pull it in as part of the build process using Maven or similar.

*Does local blobs get sent to the server if the server never has the branch they were produced on??


	[[1]] Most File Actions appear to be available under the:

			<Right Click>-->Team menu

			[[1]] There is also a series of Git Views


			Window --> Show View --> Other --> Git
		Git Interactive Rebase
		Git Reflog
		Git Repositories
		Git Staging
		Git Tree Compare

		[[1]] Syntactically it seems similar to SVN

		git add <file>

		git commit -m "Some message"

		git status

		git log

		git rm

		[[1]] Not sure how to perform a  "git status" under the GUI...
		..Possibly it is the Git Staging View which gives this information.




		[[1]] Unlike SVN, it is possible for commits to have one or more Labels attached to them)

		[[1]] Token Expansion  ( $Author$, $Date$ etc.)

	git does not have this functionality out of the box, accept as far as I can tell, for the $Id$ reference, which will
	inject the SHA-1 of the blob.

	However the functionality can be replicated by way of clean and smudge filters:
		A Smudge filter is run on Checkout, and will pre-process the file coming out of the repository in any way you want
		A Clean Filter will run on Commit and pre-process the file before committing.






		[[1]] Repository Stuff

		git init

		git clone



		[[1]] git config

	Available under the Git Repositoreis view

	and also the

	git config user.name = "some name"
	git config user.email =  "kevin.crocombe@wherever"

	Can also just edit the config files with a text editore

		.git/config


	[[1]] Git stores files named not after their filename, but after the SHA1 hash of their contents. So 2 files with diff names but same content will be considered the same object ( and stored just once)
