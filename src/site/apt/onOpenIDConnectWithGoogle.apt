
Using OpenID Connect Authentication to Secure Restful API with Google


	NB This is in essence, an extension to  Oauth2. ( OAuth is really about authorisation
	while OpenID connect is about Authentication)

	Google Documentation is very good, and its here.
		https://developers.google.com/accounts/docs/OpenIDConnect


	The token that is generated is an ID Token rather than an Access Token ( explained later) ( although in the following an
	Access Token is generated as well). It takes the form of a JWT ( Json Web Token). It identifies such things as:

		the Issuer od the token
		the id of the bearer as known by the Issuer.
		The set of Application Id’s it is valid for
		Time of issue
		Time of expiration
		Method of authentication




*Open Id Connect with google.

	1) At the google developers console, create a projects e.g. tifosi.

	2) Create a new OAuth Credentials.
		This will generate:

			Client ID
			Client Secret

		In order to be used, one or more redirect URI  (in this example https://mycallback.com ) needs to be specified. Once the
		authenticating server has performed the authentication in its browser, this is where control will be passed ( along
		with the Authorisation Token)


		Note the CLIENT_ID and Client Secret - they will been too be known by the users of the service.



	3) Firstly, get the the Authorization Token by browsing to the below, supplying the clientID from above.

	NB in a browser

---
	https://accounts.google.com/o/oauth2/auth?\
	scope=openid email&\
	state=mystate&\
	redirect_uri=https://mycallback.com\
	&response_type=code&\
	client_id=1087322112527-tvskdfn2vl8qu13r7tgvnuarnfuchu35.apps.googleusercontent.com&\
	approval_prompt=force
---

	‘state’ is essentially just a random number generated by the client and sent to the server. When it responds the server will send back the same
	random number. The client can then check this value against the original in ordewr to confirm that the response is indeed coming from the
	intended recipient ( NB for this reason, must be sent over HTTPS )


	Google will open a login window if necessary, and prompt user to login. This is important. It is the Authentication Server that
	is opening the window ( https ) NOT the client. The client is not receiving the username/password in any way. Hence the need for a
	browser capability in the client : this is how the to Authorization server login window is displayed.

	Depending on the value of the ‘scope’ parameter, the authorisation server may ask the user to confirm he/she is allowing access
	to a portion of the personal data registered at the Authentication Service. In this example, we are asking for both:
		an OpenId token
		access to Email address

	Note the redirect url MUST be one on the list registered at the Authoriser ( this is to prevent someone stealing tokens by
	requesting that they be sent to some arbitrary location).

	The response type of ‘code’ - says we want an authorisation code returned to us.
		‘code’ launches a ‘Basic Flow’ scenario
		‘token id_token’ launches a ‘Implicit Flow’ scenario and requires JavaScript at the redirect URI to retrieve the tokens.




	4) If successful, This will redirect as follows,  and supply an authorisation code...

---
	https://mycallback.com/?\
	state=mystate&\
	code=4/3OV8XhXD-1TokX8N6bbNBEVGEFI3SKLs3h6zQmv6JJU.YqFCE3mRHRQToiIBeO6P2m8qACnDlwI&authuser=0&\
	num_sessions=1&\
	prompt=consent&\
	session_state=4e5029b1430e04314a4371f2cec00f4d35abbbb8..83b7
---


	User should confirm that ‘state’ matches the one sent out.


	5) The Authorisation Token is a one-time use and relatively short lived thing ( 10 mins max ).We now need to exchange the Authorisation Token for an Access Token ( or Bearer Token ). I think the Authorisation Token is no more than a temporary set of credentials that gives access to the token endpoint.

	In making the call, we need to provide the Authorisation token, client_id and client_secret and be redirected to the same URL as before

	We must use HTTPS in order to protect the value of the client_secret.

---
	curl -v -X POST \
	-d "grant_type=authorization_code&\
	code=4/3OV8XhXD-1TokX8N6bbNBEVGEFI3SKLs3h6zQmv6JJU.YqFCE3mRHRQToiIBeO6P2m8qACnDlwI&\
	client_id=1087322112527-tvskdfn2vl8qu13r7tgvnuarnfuchu35.apps.googleusercontent.com&\
	client_secret=HKIjW4bpk7zayCKjRtNG2nMg&\
	redirect_uri=https://mycallback.com" \
	https://accounts.google.com/o/oauth2/token
---

	Which will return :

---
	* Adding handle: conn: 0x7fe019804000
	* Adding handle: send: 0
	* Adding handle: recv: 0
	* Curl_addHandleToPipeline: length: 1
	* - Conn 0 (0x7fe019804000) send_pipe: 1, recv_pipe: 0
	* About to connect() to accounts.google.com port 443 (#0)
	*   Trying 216.58.209.237...
	* Connected to accounts.google.com (216.58.209.237) port 443 (#0)
	* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
	* Server certificate: accounts.google.com
	* Server certificate: Google Internet Authority G2
	* Server certificate: GeoTrust Global CA
	* Server certificate: Equifax Secure Certificate Authority
	> POST /o/oauth2/token HTTP/1.1
	> User-Agent: curl/7.30.0
	> Host: accounts.google.com
	> Accept: */*
	> Content-Length: 271
	> Content-Type: application/x-www-form-urlencoded
	>
	* upload completely sent off: 271 out of 271 bytes
	< HTTP/1.1 200 OK
	< Content-Type: application/json; charset=utf-8
	< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
	< Pragma: no-cache
	< Expires: Fri, 01 Jan 1990 00:00:00 GMT
	< Date: Tue, 03 Mar 2015 21:48:56 GMT
	< Content-Disposition: attachment; filename="json.txt"; filename*=UTF-8''json.txt
	< X-Content-Type-Options: nosniff
	< X-Frame-Options: SAMEORIGIN
	< X-XSS-Protection: 1; mode=block
	* Server GSE is not blacklisted
	< Server: GSE
	< Alternate-Protocol: 443:quic,p=0.08
	< Accept-Ranges: none
	< Vary: Accept-Encoding
	< Transfer-Encoding: chunked
	<
	{
	  "access_token" : "ya29.KwGDS9egnn9aQsU-UeRKCiJn3cXISdHqSAtvdcnnT7xEf3XtMf_XNi7LqnGcbQ94Mm0s37SFwM_PWQ",
	  "token_type" : "Bearer",
	  "expires_in" : 3600,
	  "id_token" : "eyJhbGciOiJSUzI1NiIsImtpZCI6IjMyYjZlMjA0MGZmMzhiZmNhNDNhZTgzNjEwNzBmNjQ3MTBiNDY5OTAifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTAzODExNTI1NjUyNDU3NzExOTQwIiwiYXpwIjoiMTA4NzMyMjExMjUyNy10dnNrZGZuMnZsOHF1MTNyN3Rndm51YXJuZnVjaHUzNS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsImVtYWlsIjoia2Nyb2NvbWJlQGdvb2dsZW1haWwuY29tIiwiYXRfaGFzaCI6InhZQUxBSGlHcGdGUzVYcGx6akZCT3ciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiMTA4NzMyMjExMjUyNy10dnNrZGZuMnZsOHF1MTNyN3Rndm51YXJuZnVjaHUzNS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsImlhdCI6MTQyNTQxOTAzNiwiZXhwIjoxNDI1NDIyOTM2fQ.irbtbh2grZHhA68K1ildUBUVloySJQuBCZSNaq5u2suFo3siGnrtzdwPt7N4F7JQhEoFVP5f1NFdwVIShaCMTM48q79C8G_2D8qgAmP9qt8lZa81BoS-1GF_0ccNa4BEq4ZdlW6Wn_ARHp37l63gz5fUs3jEaid1m42P6eTPl_0"
	* Connection #0 to host accounts.google.com left intact
	}
---


	In this example 2 tokens are returned.

		The Access Token is specific to google, and is used to get access to the google-held info that the user has consented to share.
		It is presented in the HTTP authentication header , and must be presented over HTTPS ( to prevent the tokens being intercepted)

		For example, the available user information can be obtained by taking to the Google Enduser endpoint.

---
			curl https://www.googleapis.com/oauth2/v1/userinfo?\
				access_token=ya29.KwGDS9egnn9aQsU-UeRKCiJn3cXISdHqSAtvdcnnT7xEf3XtMf_XNi7LqnGcbQ94Mm0s37SFwM_PWQ
---

		will return:

---
	{
	 "id": "103811525652457711940",
	 "email": "kcrocombe@googlemail.com",
	 "verified_email": true,
	 "name": "kevin crocombe",
	 "given_name": "kevin",
	 "family_name": "crocombe",
	 "link": "https://plus.google.com/103811525652457711940",
	 "picture": "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg",
	 "gender": "other"
	}
---





	The id_token is a OpenId Connect standard token and is what we use to demonstrate to any other interested application that the user
	has been authenticated ( in this case by google).

	It is a cryptographically signed  base64 Json Web Token (JWT) encoded in 3 parts ( Header, Body, Signature separated by dots ) , and when it is decoded is

---
	Header
		{“alg":"RS256","kid":"32b6e2040ff38bfca43ae8361070f64710b46990"}

	Body
	{"iss":"accounts.google.com","sub":"103811525652457711940","azp":"1087322112527-tvskdfn2vl8qu13r7tgvnuarnfuchu35.apps.googleusercontent.com","email":"kcrocombe@googlemail.com","at_hash":"xYALAHiGpgFS5XplzjFBOw","email_verified":true,"aud":"1087322112527-tvskdfn2vl8qu13r7tgvnuarnfuchu35.apps.googleusercontent.com","iat":1425419036,"exp":1425422936}

	Signature
		( not displayable )
---


	This particular token is good for 3600 secs ( ish ) or just over an hour.




	This then is the bit that we will use to Authorize access to out protected API’s

	Note the sub: field indicates the id of the user at google ( in this case )

	NB - The recipient of the token will need to verify that the token is valid before accepting it. This will involve

	a) Verify that the ID token is a JWT which is properly signed with an appropriate Google public key.
	b) Verify that the value of aud (audience) or possibly azp ( client_id of the presenter) in the ID token is equal to your app’s client ID.
	c) Verify that the value of iss ( issuer ) in the ID token is equal to the expected issuer  in this case accounts.google.com or https://accounts.google.com. )
	d) Verify that the expiry time (exp) of the ID token has not passed.


	Items b)c)d) ar trivial to confirm.

	Item a) involves checking that the typographical signature correctly describes the JWT passed. There are ac couple of ways of doing this :
		a) make uses of the authorisers token info endpoint ( for google : https://www.googleapis.com/oauth2/v1/tokeninfo )


	Note : below we are using a different ID token to above ( the original one expired )

---
	curl https://www.googleapis.com/oauth2/v1/tokeninfo?id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjNkOTI0NmE2NmUwYjEzM2EyY2I4MWRjOWIwYmFhNDJiZTRkN2QxZDUifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTAzODExNTI1NjUyNDU3NzExOTQwIiwiYXpwIjoiMTA4NzMyMjExMjUyNy10dnNrZGZuMnZsOHF1MTNyN3Rndm51YXJuZnVjaHUzNS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsImVtYWlsIjoia2Nyb2NvbWJlQGdvb2dsZW1haWwuY29tIiwiYXRfaGFzaCI6ImRGaVB0Z3RNT21aNEhOT0JENzl0b3ciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiMTA4NzMyMjExMjUyNy10dnNrZGZuMnZsOHF1MTNyN3Rndm51YXJuZnVjaHUzNS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsImlhdCI6MTQyNTU1NjE0NSwiZXhwIjoxNDI1NTU5OTI1fQ.iQOYaDWkQ8hEncha9eqPTU0c3MMwPYnfpym2o8smQunWu6lNfKLsdPrSIVY0N48Gu-y88X7dwxgBjqquspdYoPrQBpOc6IVwKEZylf57dfe5usn5473lK-7wSqgt4eS-VPxfBd4QVtrgbVNWqvQJe_H6-dzBXNj6Lr8Qd5Wbnug
---

	This returns

---
	{
	 "issuer": "accounts.google.com",
	 "issued_to": "1087322112527-tvskdfn2vl8qu13r7tgvnuarnfuchu35.apps.googleusercontent.com",
	 "audience": "1087322112527-tvskdfn2vl8qu13r7tgvnuarnfuchu35.apps.googleusercontent.com",
	 "user_id": "103811525652457711940",
	 "expires_in": 3438,
	 "issued_at": 1425556145,
	 "email": "kcrocombe@googlemail.com",
	 "email_verified": true
	}
---

	While this method is useful for debugging, it is too network intensive to use in production.

	b) Download the public keys from google and check the signature locally.

		The google public keys are available on

			https://www.googleapis.com/oauth2/v2/certs


		These change daily, so should be downloaded periodically and cached this is what they look like:

---
	{
	 "keys": [
	  {
	   "kty": "RSA",
	   "alg": "RS256",
	   "use": "sig",
	   "kid": "3d9246a66e0b133a2cb81dc9b0baa42be4d7d1d5",
	   "n": "wXAXtE0gTwI2SGUMTW4VRYFlZvbPisjHYYpJyAhS3v4G63cc6tbNqP_58lWr6Adg97rWTwd_1_Zmh_a_4sT72KTeS_CjqxACzQ_tbr4tyuE61lTmEeUTV6T6duqtmdoGBiaQmyfs2YS44mnOEW-4-ll59ttUkIY12gCUloFfhsE=",
	   "e": "AQAB"
	  },
	  {
	   "kty": "RSA",
	   "alg": "RS256",
	   "use": "sig",
	   "kid": "581ddf85951f7ec5c17367033e539d176976d91d",
	   "n": "r3YyNqtPYWPnrav-MfdWepTlGJH47W8PgoNSg1ThQbGzF11iDr5yuhPFJWgkaKjqpy5MqjSKiUENx7nzvH6PYN_idl2mxbtkTB7VyXi8yV4pwWSsvnA_Gixqn1G9XgqH-h47L5eCn16rS2omRFPKWafl0qLOgdDRMARyKzQD2q0=",
	   "e": "AQAB"
	  }
	 ]
	}
---

	I presume there are 2 here.











	0

	Information as to where to get the various open-id information from google can be obtained by querying the
	following end-point.

---
	curl https://accounts.google.com/.well-known/openid-configuration



	{
	 "issuer": "accounts.google.com",
	 "authorization_endpoint": "https://accounts.google.com/o/oauth2/auth",
	 "token_endpoint": "https://www.googleapis.com/oauth2/v3/token",
	 "userinfo_endpoint": "https://www.googleapis.com/plus/v1/people/me/openIdConnect",
	 "revocation_endpoint": "https://accounts.google.com/o/oauth2/revoke",
	 "jwks_uri": "https://www.googleapis.com/oauth2/v2/certs",
	 "response_types_supported": [
	  "code",
	  "token",
	  "id_token",
	  "code token",
	  "code id_token",
	  "token id_token",
	  "code token id_token",
	  "none"
	 ],
	 "subject_types_supported": [
	  "public"
	 ],
	 "id_token_alg_values_supported": [
	  "RS256"
	 ],
	 "token_endpoint_auth_methods_supported": [
	  "client_secret_post"
	 ]
	}
---




===

	Need to work out how to do it with Facebook. ( which just isn’t as good)



	NB this is an Oauth2 session not openConnect

	Facebook does not support open Connect. Instead it uses its own Oauth2 based system.

	The principle difference, is that it doesn't use id_tokens. Instaed it just generates an access_token which you can use in
	a slightly different way.

	The principle difference is that you use the access token that has granted you access to facebook as the token signify authentication.
	While this works ok up to a point, it seems to break down when the token needs to get passed to the API server.
	The only way the server has of checking validity is to call the facebook endpoint and pass the token. This means it is going to be calling
	facebook for every protected server API call. ( as opposed to google, which you can just download the certificates for and validate
	locally.).


	1) Login in and get the Authorization Token

	Note that in this case, the scope is publish_actions ( which will allow posting to face book). If we leave scope blank, we will get
	the minimum privs.

	https://www.facebook.com/dialog/oauth?client_id=1568066833431528&redirect_uri=https://www.facebook.com/connect/login_success.html&scope=publish_actions

	This returns:

---
	https://www.facebook.com/connect/login_success.html?code=AQD_dGYzDQsvKOze9brVZUhGfgp2sD-iZBcuuaPFbtgoStaOSFl2ik1RDM03aQeK8uMoUD2WEzD3--c4mUf_lxrU8DcomilnnN8D90F9_IveZO0UAiSAhK9v7GDuXdBU5td0jMaaAhr4tgvn1Os35WTfE5yYMC5VRF4IJbPli6pKvdCNtjfJfzkuezCVu0vzm09-NcAX71iBHu6KnSxaz6WKaHKW7zK6OO5Umnj50rVwag2hHmRzXmTaGYgaIuzRcfN_o_oxm-TSNaCSjMeXh-e-MhImRj-Ar78VlqO5yJehEE3tf7e_2H053uKGgpEllEw#_=_
---


	2) The authorization token is now exchanged for an acces token. Again this is much like OpenID Connect.

---
	https://graph.facebook.com/oauth/access_token?client_id=1568066833431528&redirect_uri=https://www.facebook.com/connect/login_success.html&client_secret=0aea98acc1ea4234c071ec24126c707a&code=AQD_dGYzDQsvKOze9brVZUhGfgp2sD-iZBcuuaPFbtgoStaOSFl2ik1RDM03aQeK8uMoUD2WEzD3--c4mUf_lxrU8DcomilnnN8D90F9_IveZO0UAiSAhK9v7GDuXdBU5td0jMaaAhr4tgvn1Os35WTfE5yYMC5VRF4IJbPli6pKvdCNtjfJfzkuezCVu0vzm09-NcAX71iBHu6KnSxaz6WKaHKW7zK6OO5Umnj50rVwag2hHmRzXmTaGYgaIuzRcfN_o_oxm-TSNaCSjMeXh-e-MhImRj-Ar78VlqO5yJehEE3tf7e_2H053uKGgpEllEw#_=_
---



---
	access_token=CAAWSJgKXOZBgBAHC2KJTq8T8c48ws0vHArbZAdLpUud4ACcHY0IJBxTvYj91aoXrIlsnw3EdmuGZAGJ2MkmOe1w3Nc27fwcUwHi2RdKOAZC96dNajOFbbVbxgXEi68ZB7hGx94thKHq1FCGuObPMwTh1pfvQKJisAGL6ZCnCwsunZCZBw4qtYTKLVrqfYcJ84ZBjFE2m1P0GeUAZDZD&expires=5181626
---


	3) The access toke can now be used to post something to Facebooks home page...

---
	curl -v -X POST -d "message=test" https://graph.facebook.com/me/feed?access_token=CAAWSJgKXOZBgBAHC2KJTq8T8c48ws0vHArbZAdLpUud4ACcHY0IJBxTvYj91aoXrIlsnw3EdmuGZAGJ2MkmOe1w3Nc27fwcUwHi2RdKOAZC96dNajOFbbVbxgXEi68ZB7hGx94thKHq1FCGuObPMwTh1pfvQKJisAGL6ZCnCwsunZCZBw4qtYTKLVrqfYcJ84ZBjFE2m1P0GeUAZDZD


	* Adding handle: conn: 0x7fdd29003a00
	* Adding handle: send: 0
	* Adding handle: recv: 0
	* Curl_addHandleToPipeline: length: 1
	* - Conn 0 (0x7fdd29003a00) send_pipe: 1, recv_pipe: 0
	* About to connect() to graph.facebook.com port 443 (#0)
	*   Trying 31.13.90.2...
	* Connected to graph.facebook.com (31.13.90.2) port 443 (#0)
	* TLS 1.2 connection using TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
	* Server certificate: *.facebook.com
	* Server certificate: DigiCert High Assurance CA-3
	* Server certificate: DigiCert High Assurance EV Root CA
	> POST /me/feed?access_token=CAAWSJgKXOZBgBAHC2KJTq8T8c48ws0vHArbZAdLpUud4ACcHY0IJBxTvYj91aoXrIlsnw3EdmuGZAGJ2MkmOe1w3Nc27fwcUwHi2RdKOAZC96dNajOFbbVbxgXEi68ZB7hGx94thKHq1FCGuObPMwTh1pfvQKJisAGL6ZCnCwsunZCZBw4qtYTKLVrqfYcJ84ZBjFE2m1P0GeUAZDZD HTTP/1.1
	> User-Agent: curl/7.30.0
	> Host: graph.facebook.com
	> Accept: */*
	> Content-Length: 12
	> Content-Type: application/x-www-form-urlencoded
	>
	* upload completely sent off: 12 out of 12 bytes
	< HTTP/1.1 200 OK
	< Content-Type: application/json; charset=UTF-8
	< Access-Control-Allow-Origin: *
	< X-FB-Rev: 1625016
	< Pragma: no-cache
	< Cache-Control: private, no-cache, no-store, must-revalidate
	< Facebook-API-Version: v2.2
	< Expires: Sat, 01 Jan 2000 00:00:00 GMT
	< X-FB-Debug: LDefdx9biq9f3lNi+3iDg8RudM7pWibMiGKE8bKdeZx+KmMswAEshxZXkceSzc0SkRRObK/GBbZjPnYvRi5New==
	< Date: Wed, 04 Mar 2015 15:55:58 GMT
	< Connection: keep-alive
	< Content-Length: 44
	<
	* Connection #0 to host graph.facebook.com left intact
	{"id":"10153122567213728_10153122567128728"}
---


	4) and info the user has agreed to share can be retrieved from facebook

---
	curl https://graph.facebook.com/me?access_token=CAAWSJgKXOZBgBAHC2KJTq8T8c48ws0vHArbZAdLpUud4ACcHY0IJBxTvYj91aoXrIlsnw3EdmuGZAGJ2MkmOe1w3Nc27fwcUwHi2RdKOAZC96dNajOFbbVbxgXEi68ZB7hGx94thKHq1FCGuObPMwTh1pfvQKJisAGL6ZCnCwsunZCZBw4qtYTKLVrqfYcJ84ZBjFE2m1P0GeUAZDZD

	{"id":"10153122567213728","first_name":"Kevin","last_name":"Crocombe","link":"https:\/\/www.facebook.com\/app_scoped_user_id\/10153122567213728\/","locale":"en_US","name":"Kevin Crocombe","timezone":0,"updated_time":"2015-03-03T22:54:32+0000","verified":true}
---
