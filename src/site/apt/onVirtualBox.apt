On Virtual box

*SMP Issue

  At the time of writing, the OSX version Virtual Box <<CANNOT>> make use of multiple cpu. If you try and start an instance specifying more than 1 cpu the box will hang as it comes up. For the time being, specify only 1 cpu per virtual server.

*Mouse capture

  The mouse can often get captured by the guest system, rendering it useless to the host os until it is released. If the guest has hung for any rason this cn be a pain.

  To Release press the Release button. THis is indicated at teh bottom right of the virtual bopx window, and is usually by Option-key ( next to Contol on the Left Hand Side.)


*Starting / Shutting Down

  VboxManage startvm

  VBoxManage controlvm <vm> acpipowerbutton

*Controlling the default boot device

  VBoxManage modifyvm  <vm> --boot1 net

  VBoxManage modifyvm  <vm> --boot1 disk

*Changing the timeout on the  Boot Options Splash Screen

    VBoxManage modifyvm <VMNAME> --bioslogodisplaytime 10000

*Capturing console output during a system boot on a Linux system

  First make sure that a suitable serial device is configured on the linux side. This is by way of a parameter to the linux kernel you are trying to boot.

    console=
        ttyS<n>  : use the specified serial port

        tty0    : use the specified Virtual console device

    ignore_loglevel : to make sure it sends everything.



    This need to provided to the kernel at boot time.  Usually these are presented to the kernel via the bootloader. If this is happening during a virtual install it will be specified on the bootloader in the PXF direcory ( ~/Library/VirtualBox/TFTP/pxelinux.cfg/default or similar).

    If in a kernel boioting from dik it will be in  /boot/loader/entris/<file>.conf or similar

    Secondly, on the VirtualBox conole, enable the corresponding serial port (Port1 for tty0), set the mode to 'RawFile' and reedirect its path to an apporpriate file.


*The Vagrant Ignition Plugin

  A plugin to vagrant (Vagrant::Ignition) exist, whose purpose is to inject Ignition json scripts inot the virtual server that it is intending to build.

  Rather than provide the scripts as command line parameters to the installer, the plugin generates  images of gpts formatted drives and places the json files it generates on that. It directs the guest os to mount the drives, and so the files become available to the guest os in a location where it knows where to look for them.

  Vagrant is cabable of generating Ignition scripts in accordance with directives in the Vagrant configuration file. Any specific ignition scripts that the user wishes to add is merged into the default before it is presented.

  This is fully described {{{https://github.com/coreos/vagrant-ignition}here}}.


*Preboot Execution Environment Installs and VirtualBox

    PXE (Preboot Execution Environment) describes a standardised client-server environment, that boots a software assembly retrieved from the network. In other words, rather then booting from a hard disk or cdrom, a clinet computer retrieves its boot image across the network.

    On the client side, it merely needs a PXE-capable network card and a config change in the BIOS to set the Network as the first choice Boot option.

    The Server side requires 2 components:

      * A DHCP service to provide the appropriate client network parameters ( e.g. ipaddress), and the address of the PXE server to be used

      * A PXE server to supply the boot image.

      []

    Often the PXE server is able to work as a DHCP proxy, so both service can be supplied from the same server.  On booting, the client will broadcast a DHCPDISCOVER packet to which the server(s) will respond.

    The PXE server will supply the boot image to the client using the tftp protocol (Trivial FTP). tftp is essentially a stripped down version of ftp, and is noptably missing any sort of authentication requirement.

    It is possible to <emulate> PXE booting within Virtualbox. The network cards within a VirtualBox environemtn are themselves virtual, and rather than looking for a PXE server on the network to supply it a boot image, it will look in a particular directory on the host operating system for the boot image. To use PXE within the virtual box environment, you need to:

      * Set the VM to use the NAT networkin as the FIRST Network device,

      * Set the VM to boot off the netowk

      * Provide a suitable boot image within hte  ~/Library/VirtualBox/TFTP of the host o/s

      []


    VirtualBox expects to find a file named <vmname>.pxe within that directory, whic hneed to be a valid boot image. The file must be named afer the virtual machine that is being booted. So, if you are booting a vm called PxeBootTest, it looks for file:

        ~/Library/VirtualBox/TFTP/PxeBootTest.pxe

    Typically this would be a soft link into the actual boot image. Note: that Virtual Box DOES not provide any boot images; you need to track down a suitable boot image for whatever o/s you want and install it yourself.

    For Linux, the pxe boot loader image forms part of the standard boot utilites available at various mirrors including the below:

      https://mirrors.edge.kernel.org/pub/linux/utils/boot/syslinux/syslinux-6.03.tar.gz

    The name of the boot loader is

      pxeLinux.0

    and it is just a pxe variant of the standard boot0/syslinux0 bootsector, and is configured in a similar way.

    pxeLinux.0 expectes to find a subdireecty

        ./pxelinux.cfg  ( NB This is a directory)

    and from within there it looks for a boot configuration file:

      It starts by looking for one named after the clients unique id ( e.g. b8945908-d6a6-41a9-611d-74a6ab80b83d)

      Then it attempts to find one based on various hardware id, and if it can't find that reads a files called:

      default.cfg

      This configuration file is described within documentation in the syslinux-6.03.tar bundle, but broadly provides the kernel image to be secondstage booted and any paramters that it might need, including the image of the virtual root defic that it should iuse.

      It will look something like the below.

   ---
      DEFAULT pxeboot
      TIMEOUT 100
      PROMPT 0
      LABEL pxeboot
          KERNEL fedora-coreos-30.20191014.0-installer-kernel-x86_64
          APPEND ip=dhcp rd.neednet=1 initrd=fedora-coreos-30.20191014.0-installer-initramfs.x86_64.img coreos.inst=yes
      	  IPAPPEND 2
   ---

      Obviously the various parameters supplied will be dependendent on the os you are tring to boot.

    Note that,  in theory, pxeLinux.0 will support both http and ftp transfers, so it would be usual in a PXE boot for the kernal and rootfs images to be network destinations, and typically would address from a TFTP server.

    <<HOWEVER>>, because our virtual network is only emulating PXE functionality it <<CANNOT>> truly see the network as it runs, only the TFTP direcory. This means that both kernel and initrd images MUST be in this location. It should also be noted that tftp seems to be a pretty slow protocol, and when it is being emulated as here it is very, slow.

    Consequently, it is only really feasible to retrieve fairly small images via this route: anything more than about 70 or 80 Mb takes to long to practically load. Hence we can only really use <installer> type images here, not full y ditributiuonus.

    Once, the kernel and intrd images have been loaded, the system is properly network aware, so other files such as Ignition scripts and raw images can be loaded from remote http or tftp locations. The http protocol shopuld be used in preference to tftp because it is much faster.

**A simple tftp Server

  trivial ftp (tftp) is a stripped down version of ftp without any authentication mechanisms

  OSX comes bundled with its own tftp server. This does not run by default. If it is not running, it can be started:

 ---
  sudo launchctl load -F /System/Library/LaunchDaemons/tftp.plist
  sudo launchctl start com.apple.tftpd
 ---

  By default tftpd uses the following folder:

 ---
    /private/tftpboot
 ---

  Be sure Read/Write/eXecute permissions are set on the tftpboot folder and any files you wish to transfer:

 ---
  sudo chmod 777 /private/tftpboot
  sudo chmod 777 /private/tftpboot/*
 ---

  Note, if youâ€™ll be transferring a file TO your TFTP server, the file will technically need to exist on the server beforehand so create it with touch. For example:

 ---
  sudo touch /private/tftpboot/<someFile>
  sudo chmod 777 /private/tftpboot/<someFile>
 ---

  Likewise, there is a tftp to send/get files using the particular protocol.


**A simple HTTP Server

  Python come packaged with a simple Http Server capable of serving files from a single directory. Just Run it from the directory containing the files to be served.

 ---
  cd <targetDir>

  python -m SimpleHTTPServer
 ---



===


*Useful command line stuff

  VBoxManage list vms

  VBoxManage start vm <vm>



*Troubleshooting

**UUID mismatches

  Especially when using vagrant, an occasional error seems to be thrown when starting up a virtualBox instance:

---
  There was an error while executing `VBoxManage`, a CLI used by Vagrant
  for controlling VirtualBox. The command and stderr is shown below.

  Command: ["startvm", "4ba3db26-dcbe-4a24-8b2a-7875e9981b1e", "--type", "headless"]

  Stderr: VBoxManage: error: UUID {b55130c6-5492-4200-aa9a-08c16ecb1f0c} of the medium '/Users/kevin/dvl/gitReps/coreos-kubernetes/multi-node/vagrant/IgnitionVirtualDisks/configDskEtcd1.vmdk' does not match the value {2535bdf5-b50a-4028-817c-716ebd7ebae3} stored in the media registry ('/Users/kevin/Library/VirtualBox/VirtualBox.xml')
  VBoxManage: error: Details: code NS_ERROR_FAILURE (0x80004005), component MediumWrap, interface IMedium
---

  The vmdk files are textual metadata files, and the UUID in question can clearly be seen in (in this case) configDskEtcd1.vmdk. The reference to the media registry is mis-leading. The clashing uuid is actually in the .vmdk file describing the virtualBox instance ( in this case in /Volumes/media/virtualBox/vagrant_e1_1577363503410_62081/coreos_production_vagrant_image.vmdk). Have been unable to discover why this happens sometimes.

  However it does seem to be fixable by editing the configDskEtcd1.vmdk and substituting the correct UUID. (It does not seem to work if you edit the coreos_production_vagrant_image.vmdk file: it just seems to think the instance has become corrupted.


  ==========================================


[./images/virtualBoxNetworking.png]
  
*Network Address Translation (NAT)

  Network Address Translation (NAT) is the simplest way of accessing an external network from a virtual machine. Usually, it does not require any configuration on the host network and guest system. For this reason, it is the default networking mode in Oracle VM VirtualBox.

  NAT acts much like having a <<router>> embedded within Host machine. The router, in this case, is the VirtualBox networking engine, which maps traffic from and to the virtual machine transparently. In VirtualBox this router is placed between each virtual machine and the host. This separation maximizes security since by default virtual machines cannot talk to each other.

  The disadvantage of NAT mode is that, much like a private network behind a router, the virtual machine is invisible and unreachable from the outside internet. You cannot make services available to the outside world from a virtual machine unless you set up {{port forwarding}}.

  The network frames sent out by the <<guest>> operating system are received by VirtualBox's NAT engine, which extracts the TCP/IP data and resends it using the <<host>> operating system. To an application on the host, or to another computer on the same network as the host, it looks like the data was sent by the VirtualBox application on the host, using an IP address belonging to the host.

  VirtualBox listens for replies to the packages sent, and repacks and resends them to the guest machine on its private network.

**The Router as a DHCP server

  The virtual machine receives its network address and configuration on the private network from a DHCP server integrated into VirtualBox internal router.

  The IP address thus assigned to the virtual machine is usually on a completely different network than that of the host. As more than one 'card' of a virtual machine can be set up to use NAT, the first NAT card connected to the private network is usaully 10.0.2.X, the second NAT card to the network 10.0.3.X and so on.

**Configuring Port Forwarding with NAT

  As the virtual machine is connected to a private network internal to VirtualBox and invisible to the host, network services on the guest are not accessible to the host machine or to other computers on the same network.

  However, like a physical router, VirtualBox can make selected services available to the world outside the guest through <<port forwarding>>. This means that VirtualBox listens to certain ports on the host and resends all packets which arrive there to the guest, on the same or a different port.

  To an application on the host or other machine on the network, it looks as though the service being proxied is actually running on the host.

*Host Only Adapter

  Host Adapter communication is restricted to the Host machine and any other Guest VM which may be present.

  A HOST_ONLY adapter  is virtual adapter which sits alongside the physical host adapter (i.e.network card). However, communication over the HOST-ONLY adapter <<does not>> use the physical host adapter at all, and so consequently, virtual machines that have JUST a HOST-ONLY adapter installed can't talk to the anything outside of the Host machine.

  (If that is desired,  a second virtual Host adapter (such as NAT) can be configured alongside the HostOnly, and external communication routed through that).

  Within the host, the adapter will typically be named vboxnetX and will carry an ip address XXX.XXX.XXX.1 (e.g.172.14.4.1).  The ip addresses of the gues vm's attached to theis device can be assigned statically, or alternatively, the adapter can act as a dhcp server, doling out ip addresses for guest os's as required.

  Setting up a Host Adapter within VirtualBox will configure:

**On the Guest

  A network interface (eth1 in the below)...

---
  ifconfig

  eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
          inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
          inet6 fe80::a00:27ff:feb1:8f2d  prefixlen 64  scopeid 0x20<link>
          ether 08:00:27:b1:8f:2d  txqueuelen 1000  (Ethernet)

  eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
          inet 172.17.4.51  netmask 255.255.0.0  broadcast 172.17.255.255
          inet6 fe80::a00:27ff:fe1e:b954  prefixlen 64  scopeid 0x20<link>
          ether 08:00:27:1e:b9:54  txqueuelen 1000  (Ethernet)
---
  ...and some routing rules.
---
    Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
    172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 eth1
---
    Basically anything destined for the 17.17.*.* gets routed through the eth1 interface (which is the HostOnly adapter when viewed for the guest side).

**On the Host

  A network interface (vboxnet4 in the below)...

---
  ifconfig

  en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
  	ether 1c:6f:65:90:63:17
  	inet6 fe80::1827:7ed6:bcec:c1b8%en0 prefixlen 64 secured scopeid 0xc
  	inet 192.168.0.17 netmask 0xffffff00 broadcast 192.168.0.255

  vboxnet4: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500
  	ether 0a:00:27:00:00:04
  	inet 172.17.4.1 netmask 0xffffff00 broadcast 172.17.4.255
---
  ...with routing tables
---
    netstat -r

    Destination        Gateway            Flags        Refs      Use   Netif Expire
    172.17.4/24        link#19            UC              2        0 vboxnet
    172.17.4.255       ff:ff:ff:ff:ff:ff  UHLWbI          0        9 vboxnet
---
    Basically anything destined for the 17.17.4/25 gets routed through the vboxnet ( which is the H/A adapter on the Host side).


*Bridging

  Bridged Networking allows full communication between any virtual machine and any other machine (or virtual machine) in the entire network.

  With bridged networking, VirtualBox uses a device driver on your host system that filters data from your physical network adapter. This driver is therefore called a net filter driver. This enables VirtualBox to:

    * intercept data from the physical network, and

    * inject data into it.

  This effectively creating a new network interface in software. When a guest is using such a new software interface, it looks to the host system as though the guest were physically connected to the interface using a network cable.

  The host can send data to the guest through that interface and receive data from it. This means that you can set up routing or bridging between the guest and the rest of your network.

  Setting up a Host Adapter within VirtualBox will configure:

**On the host

  No new interfaces. The bridge works by filtering stuff out from the existing en0 interface

---
  ifconfig

  en0: flags=8963<UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500
  	ether 1c:6f:65:90:63:17
  	inet6 fe80::1827:7ed6:bcec:c1b8%en0 prefixlen 64 secured scopeid 0xc
  	inet 192.168.0.17 netmask 0xffffff00 broadcast 192.168.0.255

---
  and also some routing rules

---
  netstat -r

  Internet:
  Destination        Gateway            Flags        Refs      Use   Netif Expire
  172.17.8/24        link#18            UC              3        0 vboxnet
  172.17.8.101       8:0:27:5:5c:88     UHLWIi          3       22 vboxnet   1180
  172.17.8.255       ff:ff:ff:ff:ff:ff  UHLWbI          0        4 vboxnet
---
    (172.17.8.101 is the ip address of one of the guest o/s, 8:0:27:5:5c:88 is the address of the h/a vboxnet3)

**On the guest

  A network interface (eth1 in the below)...

---
  eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
          inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
          inet6 fe80::a00:27ff:feb1:8f2d  prefixlen 64  scopeid 0x20<link>
          ether 08:00:27:b1:8f:2d  txqueuelen 1000  (Ethernet)

  eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
          inet 172.17.8.101  netmask 255.255.0.0  broadcast 172.17.255.255
          inet6 fe80::a00:27ff:fe05:5c88  prefixlen 64  scopeid 0x20<link>
          ether 08:00:27:05:5c:88  txqueuelen 1000  (Ethernet)
---

  and also some routing rules....

---
  netstat -r

    Kernel IP routing table
    Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
    172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 eth1
---
